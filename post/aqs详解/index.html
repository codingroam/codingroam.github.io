<!doctype html><html lang=zh-cn dir=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>AQS详解 - 想学啊你</title><meta name=keywords content="博客"><meta name=author content="roam"><meta property="og:title" content="AQS详解"><meta property="og:site_name" content="想学啊你"><meta property="og:image" content="https://codingroam.github.io/img/author.jpg"><meta name=title content="AQS详解 - 想学啊你"><meta name=description content="轻轻的你来了"><link rel="shortcut icon" href=https://codingroam.github.io/img/favicon.ico><link rel=apple-touch-icon href=https://codingroam.github.io/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://codingroam.github.io/img/apple-touch-icon.png><link href=//unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.css rel=stylesheet><link href=https://codingroam.github.io/css/main.css rel=stylesheet type=text/css><link href=https://codingroam.github.io/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-Hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>想学啊你</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>三四楼那么高了</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-active"><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/tags rel=section><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class=menu-item><a href=/categories rel=section><i class="menu-item-icon fa fa-fw fa-book"></i><br>分类</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://codingroam.github.io/post/aqs%E8%AF%A6%E8%A7%A3/ itemprop=url>AQS详解</a></h1><div class=post-meta><span class=post-pushdate><i class="fa fa-calendar-o fa-fw"></i>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2023-08-08">2023-08-08</time></span>
<span class=post-category><i class="fa fa-folder-o fa-fw"></i>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/java itemprop=url rel=index><span itemprop=name>Java</span></a>
&nbsp;</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B itemprop=url rel=index><span itemprop=name>并发编程</span></a>
&nbsp;</span></span>
<span class=post-wordcount><i class="fa fa-file-word-o fa-fw"></i>
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>9823 字</span></span>
<span class=post-readtime><i class="fa fa-eye fa-fw"></i>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>20分钟</span></span>
<span id=/post/aqs%E8%AF%A6%E8%A7%A3/ class="leancloud_visitors post-visitor" data-flag-title=AQS详解><i class="fa fa-binoculars fa-fw"></i>
<span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>AQS详解</p><p>AQS（AbstractQueuedSynchronizer）就是一个抽象的队列同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它。</p><p>AQS 设计基于模板方法模式，开发者需要继承同步器并且重写指定的方法，将其组合在并发组件的实现中，调用同步器的模板方法，模板方法会调用使用者重写的方法。</p><p>AQS 定义了一套多线程访问共享资源的同步器框架，是整个包的基石，<code>Lock</code>、<code>ReadWriteLock</code>、<code>CountDowndLatch</code>、<code>CyclicBarrier</code>、<code>Semaphore</code>、<code>ThreadPoolExecutor</code>等都是在 AQS 的基础上实现的。</p><p>AQS 内部维护一个 FIFO 队列来管理锁。线程会首先尝试获取锁，如果失败，则将当前线程以及等待状态等信息包成一个 Node 节点加到同步队列里。</p><p>接着会不断循环尝试获取锁（条件是当前节点为 head 的直接后继才会循环尝试）, 如果失败或者不是 head 的后继节点，则会阻塞自己，直至被唤醒；而当持有锁的线程释放锁时（或取消时），会唤醒队列中的后继线程。</p><p>下面列举 JDK 中几种常见使用了 AQS 的同步组件：</p><ul><li><strong>ReentrantLock</strong>: 使用了 AQS 的独占获取和释放, 用 state 变量记录线程获取独占锁的次数, 获取锁时 + 1，释放锁时 - 1，等于 0 时表示没有线程占用锁，可以尝试获取锁。</li><li><strong>Semaphore</strong>: 使用了 AQS 的共享获取和释放，用 state 变量作为计数器，只有在大于 0 时允许线程进入。获取锁时 - 1，释放锁时 + 1。</li><li><strong>CountDownLatch</strong>: 使用了 AQS 的共享获取和释放，用 state 变量作为计数器，在初始化时指定 (即 CountDownLatch 的入参 count)。只要 state 还大于 0，获取共享锁会因为失败而阻塞，直到计数器的值为 0 时，共享锁才允许获取，当前等待线程会被唤醒。</li></ul><p>AQS 主要做了三件事情</p><ul><li>同步状态的管理</li><li>线程的阻塞和唤醒</li><li>同步队列的维护</li></ul><p>下面三个 protected final 方法是 AQS 中用来访问 / 修改同步状态的方法:</p><ul><li>int getState(): 获取同步状态</li><li>void setState(): 设置同步状态</li><li>boolean compareAndSetState(int expect, int update)：基于 CAS，原子设置当前状态</li></ul><p>并发控制的核心是锁的获取与释放，锁的实现方式有很多种，AQS 采用的是一种改进的 <strong>CLH 锁</strong>。</p><h2 id=源自-clh-锁>源自 CLH 锁</h2><p><strong>CLH</strong>(Craig, Landin, and Hagersten locks) 是一种<strong>自旋锁</strong>，发明出来的主要原因是为了解决多核 cpu 体系中全部加锁线程都访问同一内存地址而出现过多内存竞争的问题。能确保无饥饿性，提供先来先服务的公平性。</p><p><strong>自旋锁</strong>是为实现保护共享资源而提出一种锁机制。</p><p>其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就是说，在任何时刻最多只能有一个执行单元获得锁。</p><p>但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。而自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，“自旋” 一词就是因此而得名。</p><p><strong>CLH 锁</strong>是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p><p>CLH 锁引入了线程节点的概念，需要加锁的线程不断的从队尾加入队列，构造出了一个逻辑上的单向链表队列；获取锁的顺序也是从队列头部开始，早加入队列的线程便能更早的获得到 CLH 锁，实现先来先服务的公平性。</p><p><strong>CLH 锁结构图</strong></p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/9c263bdb1e5e6effda217bdad19baa68.png alt></p><p><strong>CLH 锁中加锁的线程不再是统一的监听同一个标识锁状态的内存地址，而是只监听队列中当前线程节点其前驱线程节点的锁状态。如此一来，便分散了不同线程加锁时所要访问的内存变量地址，相比起前面介绍的原始自旋锁和票锁减少了大量的内存访问竞争，减少了底层为了实现线程间内存数据可见性同步时的性能开销。</strong></p><p>加锁时，先 cas 的入队获取前驱节点后，便不断的循环监听前驱节点锁的状态，当发现前驱节点释放了锁时，当前节点便获得了锁。</p><p>而解锁时则很简单，将当前线程自己的锁状态更改为已释放即可。标识为已释放时，存在的后继加锁节点便能感知到这一变化，从而获得锁。</p><h2 id=aqs-数据模型>AQS 数据模型</h2><p>AQS 维护了一个<code>volatile int state</code>（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/a1c78d9aa99f365f81f7526412cd3c52.png alt></p><p>AQS 的内部队列是 CLH 同步锁的一种变形。其主要从以下方面进行了改造：</p><ul><li>在结构上引入了头节点和尾节点，分别指向队列的头和尾，尝试获取锁、入队列、释放锁等实现都与头尾节点相关，</li><li>为了可以处理 timeout 和 cancel 操作，每个 node 维护一个指向前驱的指针。如果一个 node 的前驱被 cancel，这个 node 可以前向移动使用前驱的状态字段</li><li>在每个 node 里面使用一个状态字段来控制阻塞 / 唤醒，而不是自旋</li><li>head 节点使用的是傀儡节点</li></ul><p>FIFO 队列中的节点有 AQS 的静态内部类<code>Node</code>定义：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>static final class Node {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    static final Node SHARED = new Node();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    static final Node EXCLUSIVE = null;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    static final int CANCELLED = 1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    static final int SIGNAL = -1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    static final int CONDITION = -2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    static final int PROPAGATE = -3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    volatile int waitStatus;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    volatile Node prev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    volatile Node next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    volatile Thread thread;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Node nextWaiter;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    final boolean isShared() {
</span></span><span style=display:flex><span>        return nextWaiter == SHARED;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    final Node predecessor() throws NullPointerException {
</span></span><span style=display:flex><span>        Node p = prev;
</span></span><span style=display:flex><span>        if (p == null) {
</span></span><span style=display:flex><span>            throw new NullPointerException();
</span></span><span style=display:flex><span>        } else {
</span></span><span style=display:flex><span>            return p;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Node() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Node(Thread thread, Node mode) {
</span></span><span style=display:flex><span>        this.nextWaiter = mode;
</span></span><span style=display:flex><span>        this.thread = thread;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Node(Thread thread, int waitStatus) {
</span></span><span style=display:flex><span>        this.waitStatus = waitStatus;
</span></span><span style=display:flex><span>        this.thread = thread;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>类中有两个常量<code>SHARE</code>和<code>EXCLUSIVE</code>，顾名思义这两个常量用于表示这个节点支持共享模式还是独占模式。</p><p><strong>共享模式</strong>指的是允许多个线程获取同一个锁而且可能获取成功。</p><p><strong>独占模式</strong>指的是一个锁如果被一个线程持有，其他线程必须等待。多个线程读取一个文件可以采用共享模式，而当有一个线程在写文件时不会允许另一个线程写这个文件，这就是独占模式的应用场景。</p><h2 id=cas-操作>CAS 操作</h2><p>AQS 有三个重要的变量：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>private transient volatile Node head;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>private transient volatile Node tail;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>private volatile int state;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>protected final int getState() {
</span></span><span style=display:flex><span>return state;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>protected final void setState(int newState) {
</span></span><span style=display:flex><span>state = newState;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>protected final boolean compareAndSetState(int expect, int update) {
</span></span><span style=display:flex><span>return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>compareAndSetState</code>方法是以乐观锁的方式更新共享资源。</p><p>CAS 指的是现代 CPU 广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。</p><p><strong>简单介绍一下这个指令的操作过程</strong></p><p>首先，CPU 会将内存中将要被更改的数据与期望的值做比较。然后，当这两个值相等时，CPU 才会将内存中的数值替换为新的值。否则便不做操作。最后，CPU 会将旧的数值返回。</p><p>这一系列的操作是原子的。它们虽然看似复杂，但却是 <strong>Java 5 并发机制优于原有锁机制的根本</strong>。简单来说，CAS 的含义是 “我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”。</p><p>CAS 通过调用 JNI（Java Native Interface）调用实现的。JNI 允许 java 调用其他语言，而 CAS 就是借助 C 语言来调用 CPU 底层指令实现的。<code>Unsafe</code>是 CAS 的核心类，它提供了硬件级别的原子操作。</p><p>大神在 java 同步器中大量使用了 CAS 技术，鬼斧神工的实现了多线程执行的安全性。CAS 不仅在 AQS 的实现中随处可见，也是整个包的基石。</p><p>可以发现，<code>head</code>、<code>tail</code>、<code>state</code>三个变量都是<code>volatile</code>的。是轻量级的，它在多处理器开发中保证了共享变量的 “可见性”。</p><p><strong>volatile 变量也存在一些局限：不能用于构建原子的复合操作，因此当一个变量依赖旧值时就不能使用 volatile 变量。而 CAS 呢，恰恰可以提供对共享变量的原子的读写操作。</strong></p><p><strong>volatile 保证共享变量的可见性，CAS 保证更新操作的原子性</strong>，简直是绝配！把这些特性整合在一起，就形成了整个 concurrent 包得以实现的基石。如果仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式：</p><ul><li>首先，声明共享变量为 volatile；</li><li>然后，使用 CAS 的原子条件更新来实现线程之间的同步；</li><li>同时，配合以 volatile 的读 / 写和 CAS 所具有的 volatile 读和写的内存语义来实现线程之间的通信。</li></ul><p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic 包中的类），这些 concurrent 包中的基础类都是使用这种模式来实现的，而 concurrent 包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent 包的实现示意图如下：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/2414911140b8478cd7014ed3c1d433ca.png alt></p><h2 id=自定义同步器的实现方法>自定义同步器的实现方法</h2><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队 / 唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><p>boolean tryAcquire(int arg)</p></td><td><p>尝试获取独占锁</p></td></tr><tr><td><p>成功则返回 true，失败则返回 false。</p></td><td></td></tr><tr><td><p>boolean tryRelease(int arg)</p></td><td><p>尝试释放独占锁</p></td></tr><tr><td><p>成功则返回 true，失败则返回 false。</p></td><td></td></tr><tr><td><p>int tryAcquireShared(int arg)</p></td><td><p>尝试获取共享锁</p></td></tr><tr><td><p>负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p></td><td></td></tr><tr><td><p>boolean tryReleaseShared(int arg)</p></td><td><p>尝试释放共享锁</p></td></tr><tr><td><p>成功则返回 true，失败则返回 false。</p></td><td></td></tr><tr><td><p>boolean isHeldExclusively()</p></td><td><p>当前线程是否获得了独占锁</p></td></tr><tr><td><p>只有用到 condition 才需要去实现它。</p></td><td></td></tr></tbody></table><p>** 例子：** 初始化为 0，表示未锁定状态。A 线程<code>lock()</code>时，会调用<code>tryAcquire()</code>独占该锁并将 state+1。此后，其他线程再时就会失败，直到 A 线程<code>unlock()</code>到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 t<code>ryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p><h2 id=aqs-定义的模板方法>AQS 定义的模板方法</h2><p>AQS 本身将同步状态的管理用模板方法模式都封装好了，以下列举了 AQS 中的一些模板方法：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><p>void acquire(int arg)</p></td><td><p>获取独占锁。会调用 tryAcquire 方法，如果未获取成功，则会进入同步队列等待</p></td></tr><tr><td><p>void acquireInterruptibly(int arg)</p></td><td><p>响应中断版本的 acquire</p></td></tr><tr><td><p>boolean tryAcquireNanos(int arg,long nanos)</p></td><td><p>响应中断 + 带超时版本的 acquire</p></td></tr><tr><td><p>void acquireShared(int arg)</p></td><td><p>获取共享锁。会调用 tryAcquireShared 方法</p></td></tr><tr><td><p>void acquireSharedInterruptibly(int arg)</p></td><td><p>响应中断版本的 acquireShared</p></td></tr><tr><td><p>boolean tryAcquireSharedNanos(int arg,long nanos)</p></td><td><p>响应中断 + 带超时版本的 acquireShared</p></td></tr><tr><td><p>boolean release(int arg)</p></td><td><p>释放独占锁</p></td></tr><tr><td><p>boolean releaseShared(int arg)</p></td><td><p>释放共享锁</p></td></tr><tr><td><p>Collection getQueuedThreads()</p></td><td><p>获取同步队列上的线程集合</p></td></tr></tbody></table><h2 id=等待状态释义>等待状态释义</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><p>CANCELLED (1)</p></td><td><p>当前线程因为超时或者中断被取消。这是一个终结态，也就是状态到此为止。</p></td></tr><tr><td><p>SIGNAL (-1)</p></td><td><p>当前线程的后继线程被阻塞或者即将被阻塞，当前线程释放锁或者取消后需要唤醒后继线程。这个状态一般都是后继线程来设置前驱节点的。</p></td></tr><tr><td><p>CONDITION (-2)</p></td><td><p>当前线程在 condition 队列中。</p></td></tr><tr><td><p>PROPAGATE (-3)</p></td><td><p>用于将唤醒后继线程传递下去，这个状态的引入是为了完善和增强共享锁的唤醒机制。在一个节点成为头节点之前，是不会跃迁为此状态的</p></td></tr><tr><td><p>0</p></td><td><p>表示无状态。</p></td></tr></tbody></table><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/f7237ec7ae1182fb57f225534a191232.png alt></p><ul><li>图为自制的 AQS 状态的流转图，AQS 中 0 状态和 CONDITION 状态为始态，CANCELLED 状态为终态。0 状态同时也可以是节点生命周期的终态。* <strong>注意，上图仅表示状态之间流转的可达性，并不代表一定能够从一个状态沿着线随意跃迁。</strong></li></ul><p>在 AQS 中包含了 head 和 tail 两个 Node 引用，其中 head 在逻辑上的含义是当前持有锁的线程，head 节点实际上是一个虚节点，本身并不会存储线程信息。当一个线程无法获取锁而被加入到同步队列时，会用 CAS 来设置尾节点 tail 为当前线程对应的 Node 节点。</p><p>head 和 tail 在 AQS 中是延迟初始化的，也就是在需要的时候才会被初始化，也就意味着在所有线程都能获取到锁的情况下，队列中的 head 和 tail 都会是 null。</p><h2 id=aqs-获取锁的流程图>AQS 获取锁的流程图</h2><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/bfafffaea4e479957cb07095c764f0cf.png alt></p><h2 id=获取独占锁的实现>获取独占锁的实现</h2><p>根据流程图进行源码的剖析，一步一步的向下走。</p><ul><li><code>acquire(int)</code>独占模式下线程获取共享资源的顶层入口。</li></ul><p>如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。获取到资源后，线程就可以去执行其临界区代码了。</p><p>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断<code>selfInterrupt()</code>，将中断补上。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>final</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>acquire</span><span style=color:#666>(</span><span style=color:#0b0;font-weight:700>int</span> arg<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(!</span>tryAcquire<span style=color:#666>(</span>arg<span style=color:#666>)</span> <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>        acquireQueued<span style=color:#666>(</span>addWaiter<span style=color:#666>(</span>Node<span style=color:#666>.</span><span style=color:#b44>EXCLUSIVE</span><span style=color:#666>),</span> arg<span style=color:#666>))</span>
</span></span><span style=display:flex><span>        selfInterrupt<span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><ul><li><code>tryAcquire(int)</code>此方法尝试去获取独占资源。如果获取成功，则直接返回 true，否则直接返回 false。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>protected</span> <span style=color:#0b0;font-weight:700>boolean</span> <span style=color:#00a000>tryAcquire</span><span style=color:#666>(</span><span style=color:#0b0;font-weight:700>int</span> arg<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>throw</span> <span style=color:#a2f;font-weight:700>new</span> UnsupportedOperationException<span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>AQS 只是一个框架，在这里定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS），至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了。</p><p>当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p><p>这里之所以没有定义成<code>abstract</code>，是因为独占模式下只用实现<code>tryAcquire(int)</code> 和<code>tryRelease(int)</code>，而共享模式下只用实现<code>tryAcquireShared(int)</code>和<code>tryReleaseShared(int)</code>。如果都定义成<code>abstract</code>，那么每个模式也要去实现另一模式下的接口。</p><ul><li><code>addWaiter(node)</code>将该线程加入等待队列的尾部，并标记为独占模式；其中，compareAndSetTail 方法也是调用 Unsafe 类实现 CAS 操作，更新队尾。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>private</span> Node <span style=color:#00a000>addWaiter</span><span style=color:#666>(</span>Node mode<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>    Node node <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> Node<span style=color:#666>(</span>Thread<span style=color:#666>.</span><span style=color:#b44>currentThread</span><span style=color:#666>(),</span> mode<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    Node pred <span style=color:#666>=</span> tail<span style=color:#666>;</span>
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>pred <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        node<span style=color:#666>.</span><span style=color:#b44>prev</span> <span style=color:#666>=</span> pred<span style=color:#666>;</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>compareAndSetTail<span style=color:#666>(</span>pred<span style=color:#666>,</span> node<span style=color:#666>))</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            pred<span style=color:#666>.</span><span style=color:#b44>next</span> <span style=color:#666>=</span> node<span style=color:#666>;</span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>return</span> node<span style=color:#666>;</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    enq<span style=color:#666>(</span>node<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> node<span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><ul><li><code>enq(node)</code> 通过循环 + CAS 在队列中成功插入一个节点后返回。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>private</span> Node <span style=color:#00a000>enq</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>final</span> Node node<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> <span style=color:#666>(;;)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        Node t <span style=color:#666>=</span> tail<span style=color:#666>;</span>
</span></span><span style=display:flex><span>				
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>t <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>compareAndSetHead<span style=color:#666>(</span><span style=color:#a2f;font-weight:700>new</span> Node<span style=color:#666>()))</span>
</span></span><span style=display:flex><span>								
</span></span><span style=display:flex><span>                tail <span style=color:#666>=</span> head<span style=color:#666>;</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span> <span style=color:#a2f;font-weight:700>else</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            node<span style=color:#666>.</span><span style=color:#b44>prev</span> <span style=color:#666>=</span> t<span style=color:#666>;</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>compareAndSetTail<span style=color:#666>(</span>t<span style=color:#666>,</span> node<span style=color:#666>))</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>                t<span style=color:#666>.</span><span style=color:#b44>next</span> <span style=color:#666>=</span> node<span style=color:#666>;</span>
</span></span><span style=display:flex><span>                <span style=color:#a2f;font-weight:700>return</span> t<span style=color:#666>;</span>
</span></span><span style=display:flex><span>            <span style=color:#666>}</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><ul><li><code>acquireQueued(node, int)</code>使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回 true，否则返回 false。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>final</span> <span style=color:#0b0;font-weight:700>boolean</span> <span style=color:#00a000>acquireQueued</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>final</span> Node node<span style=color:#666>,</span> <span style=color:#0b0;font-weight:700>int</span> arg<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0b0;font-weight:700>boolean</span> failed <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>true</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>try</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>				
</span></span><span style=display:flex><span>        <span style=color:#0b0;font-weight:700>boolean</span> interrupted <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>for</span> <span style=color:#666>(;;)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>final</span> Node p <span style=color:#666>=</span> node<span style=color:#666>.</span><span style=color:#b44>predecessor</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>p <span style=color:#666>==</span> head <span style=color:#666>&amp;&amp;</span> tryAcquire<span style=color:#666>(</span>arg<span style=color:#666>))</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>								
</span></span><span style=display:flex><span>                setHead<span style=color:#666>(</span>node<span style=color:#666>);</span>
</span></span><span style=display:flex><span>                p<span style=color:#666>.</span><span style=color:#b44>next</span> <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>;</span> 
</span></span><span style=display:flex><span>                failed <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>                <span style=color:#a2f;font-weight:700>return</span> interrupted<span style=color:#666>;</span>
</span></span><span style=display:flex><span>            <span style=color:#666>}</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>shouldParkAfterFailedAcquire<span style=color:#666>(</span>p<span style=color:#666>,</span> node<span style=color:#666>)</span> <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>                parkAndCheckInterrupt<span style=color:#666>())</span>
</span></span><span style=display:flex><span>                interrupted <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>true</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span> <span style=color:#a2f;font-weight:700>finally</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>failed<span style=color:#666>)</span>
</span></span><span style=display:flex><span>            cancelAcquire<span style=color:#666>(</span>node<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>如果获取资源失败后，会调用两个函数，<code>shouldParkAfterFailedAcquire</code>和<code>parkAndCheckInterrupt</code></p><ul><li><code>shouldParkAfterFailedAcquire(pred, node)</code>根据前驱节点中的 waitStatus 来判断是否需要阻塞当前线程。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>private</span> <span style=color:#a2f;font-weight:700>static</span> <span style=color:#0b0;font-weight:700>boolean</span> <span style=color:#00a000>shouldParkAfterFailedAcquire</span><span style=color:#666>(</span>Node pred<span style=color:#666>,</span> Node node<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0b0;font-weight:700>int</span> ws <span style=color:#666>=</span> pred<span style=color:#666>.</span><span style=color:#b44>waitStatus</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>ws <span style=color:#666>==</span> Node<span style=color:#666>.</span><span style=color:#b44>SIGNAL</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>true</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>ws <span style=color:#666>&gt;</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>do</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>						
</span></span><span style=display:flex><span>            node<span style=color:#666>.</span><span style=color:#b44>prev</span> <span style=color:#666>=</span> pred <span style=color:#666>=</span> pred<span style=color:#666>.</span><span style=color:#b44>prev</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span> <span style=color:#a2f;font-weight:700>while</span> <span style=color:#666>(</span>pred<span style=color:#666>.</span><span style=color:#b44>waitStatus</span> <span style=color:#666>&gt;</span> <span style=color:#666>0</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>        pred<span style=color:#666>.</span><span style=color:#b44>next</span> <span style=color:#666>=</span> node<span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span> <span style=color:#a2f;font-weight:700>else</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>         
</span></span><span style=display:flex><span>        compareAndSetWaitStatus<span style=color:#666>(</span>pred<span style=color:#666>,</span> ws<span style=color:#666>,</span> Node<span style=color:#666>.</span><span style=color:#b44>SIGNAL</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>整个流程中，如果前驱节点的状态不是<code>SIGNAL</code>，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p><ul><li><code>parkAndCheckInterrupt()</code>让线程去休息，真正进入等待状态。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>private</span> <span style=color:#a2f;font-weight:700>final</span> <span style=color:#0b0;font-weight:700>boolean</span> <span style=color:#00a000>parkAndCheckInterrupt</span><span style=color:#666>()</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>		LockSupport<span style=color:#666>.</span><span style=color:#b44>park</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>this</span><span style=color:#666>);</span> 
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>return</span> Thread<span style=color:#666>.</span><span style=color:#b44>interrupted</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p><code>park()</code>会让当前线程进入<code>waiting</code>状态。</p><p>在此状态下，有两种途径可以唤醒该线程：被<code>unpark()</code>或被<code>interrupt()</code>。</p><ul><li><code>cancelAcquire(node)</code>实现某个 node 取消获取锁。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>private</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>cancelAcquire</span><span style=color:#666>(</span>Node node<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>node <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>       <span style=color:#a2f;font-weight:700>return</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   node<span style=color:#666>.</span><span style=color:#b44>thread</span> <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   Node pred <span style=color:#666>=</span> node<span style=color:#666>.</span><span style=color:#b44>prev</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>   <span style=color:#a2f;font-weight:700>while</span> <span style=color:#666>(</span>pred<span style=color:#666>.</span><span style=color:#b44>waitStatus</span> <span style=color:#666>&gt;</span> <span style=color:#666>0</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>       node<span style=color:#666>.</span><span style=color:#b44>prev</span> <span style=color:#666>=</span> pred <span style=color:#666>=</span> pred<span style=color:#666>.</span><span style=color:#b44>prev</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   Node predNext <span style=color:#666>=</span> pred<span style=color:#666>.</span><span style=color:#b44>next</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   node<span style=color:#666>.</span><span style=color:#b44>waitStatus</span> <span style=color:#666>=</span> Node<span style=color:#666>.</span><span style=color:#b44>CANCELLED</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>node <span style=color:#666>==</span> tail <span style=color:#666>&amp;&amp;</span> compareAndSetTail<span style=color:#666>(</span>node<span style=color:#666>,</span> pred<span style=color:#666>))</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>       compareAndSetNext<span style=color:#666>(</span>pred<span style=color:#666>,</span> predNext<span style=color:#666>,</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>   <span style=color:#666>}</span> <span style=color:#a2f;font-weight:700>else</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       <span style=color:#0b0;font-weight:700>int</span> ws<span style=color:#666>;</span>
</span></span><span style=display:flex><span>       <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>pred <span style=color:#666>!=</span> head <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>           <span style=color:#666>((</span>ws <span style=color:#666>=</span> pred<span style=color:#666>.</span><span style=color:#b44>waitStatus</span><span style=color:#666>)</span> <span style=color:#666>==</span> Node<span style=color:#666>.</span><span style=color:#b44>SIGNAL</span> <span style=color:#666>||</span>
</span></span><span style=display:flex><span>            <span style=color:#666>(</span>ws <span style=color:#666>&lt;=</span> <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span> compareAndSetWaitStatus<span style=color:#666>(</span>pred<span style=color:#666>,</span> ws<span style=color:#666>,</span> Node<span style=color:#666>.</span><span style=color:#b44>SIGNAL</span><span style=color:#666>)))</span> <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>           pred<span style=color:#666>.</span><span style=color:#b44>thread</span> <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>           Node next <span style=color:#666>=</span> node<span style=color:#666>.</span><span style=color:#b44>next</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>           <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>next <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>null</span> <span style=color:#666>&amp;&amp;</span> next<span style=color:#666>.</span><span style=color:#b44>waitStatus</span> <span style=color:#666>&lt;=</span> <span style=color:#666>0</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>               compareAndSetNext<span style=color:#666>(</span>pred<span style=color:#666>,</span> predNext<span style=color:#666>,</span> next<span style=color:#666>);</span>
</span></span><span style=display:flex><span>       <span style=color:#666>}</span> <span style=color:#a2f;font-weight:700>else</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>           unparkSuccessor<span style=color:#666>(</span>node<span style=color:#666>);</span>
</span></span><span style=display:flex><span>       <span style=color:#666>}</span>
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>       node<span style=color:#666>.</span><span style=color:#b44>next</span> <span style=color:#666>=</span> node<span style=color:#666>;</span> 
</span></span><span style=display:flex><span>   <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><ul><li><code>unparkSuccessor(node)</code>唤醒后继线程。</li></ul><p>一句话概括：用<code>unpark()</code>唤醒等待队列中最前边的那个未放弃线程。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>private</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>unparkSuccessor</span><span style=color:#666>(</span>Node node<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#0b0;font-weight:700>int</span> ws <span style=color:#666>=</span> node<span style=color:#666>.</span><span style=color:#b44>waitStatus</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>ws <span style=color:#666>&lt;</span> <span style=color:#666>0</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>        compareAndSetWaitStatus<span style=color:#666>(</span>node<span style=color:#666>,</span> ws<span style=color:#666>,</span> <span style=color:#666>0</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Node s <span style=color:#666>=</span> node<span style=color:#666>.</span><span style=color:#b44>next</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>s <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>null</span> <span style=color:#666>||</span> s<span style=color:#666>.</span><span style=color:#b44>waitStatus</span> <span style=color:#666>&gt;</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        s <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>				
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>for</span> <span style=color:#666>(</span>Node t <span style=color:#666>=</span> tail<span style=color:#666>;</span> t <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>null</span> <span style=color:#666>&amp;&amp;</span> t <span style=color:#666>!=</span> node<span style=color:#666>;</span> t <span style=color:#666>=</span> t<span style=color:#666>.</span><span style=color:#b44>prev</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>t<span style=color:#666>.</span><span style=color:#b44>waitStatus</span> <span style=color:#666>&lt;=</span> <span style=color:#666>0</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>                s <span style=color:#666>=</span> t<span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>s <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>				
</span></span><span style=display:flex><span>        LockSupport<span style=color:#666>.</span><span style=color:#b44>unpark</span><span style=color:#666>(</span>s<span style=color:#666>.</span><span style=color:#b44>thread</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h2 id=总结-acquire-的流程>总结 acquire 的流程</h2><ul><li>调用自定义同步器的<code>tryAcquire()</code>尝试直接去获取资源，如果成功则直接返回；</li><li>没成功，则<code>addWaiter()</code>将该线程加入等待队列的尾部，并标记为独占模式；</li><li><code>acquireQueued()</code>使线程在等待队列中休息，有机会时（轮到自己，会被<code>unpark()</code>）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回 true，否则返回 false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断<code>selfInterrupt()</code>，将中断补上。</li></ul><h2 id=释放独占锁的实现>释放独占锁的实现</h2><p>对于释放一个独占锁，首先会调用<code>tryRelease(int)</code>，在完全释放掉独占锁后，这时后继线程是可以获取到独占锁的，因此释放者线程需要做的事情是唤醒一个队列中的后继者线程，让它去尝试获取独占锁。</p><p>上述所谓完全释放掉锁的含义，简单来说就是当前锁处于无主状态，等待线程有可能可以获取。</p><p>举例：对于可重入锁 ReentrantLock, 每次 tryAcquire 后，state 会 + 1，每次 tryRelease 后，state 会 - 1，如果 state 变为 0 了，则此时称独占锁被完全释放了。</p><ul><li><code>release(int)</code> 释放锁的入口</li></ul><p><code>release(int)</code>是<code>acquire(int)</code>的逆操作，是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即 state=0）, 它会唤醒等待队列里的其他线程来获取资源。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>final</span> <span style=color:#0b0;font-weight:700>boolean</span> <span style=color:#00a000>release</span><span style=color:#666>(</span><span style=color:#0b0;font-weight:700>int</span> arg<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>tryRelease<span style=color:#666>(</span>arg<span style=color:#666>))</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Node h <span style=color:#666>=</span> head<span style=color:#666>;</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>				
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>h <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>null</span> <span style=color:#666>&amp;&amp;</span> h<span style=color:#666>.</span><span style=color:#b44>waitStatus</span> <span style=color:#666>!=</span> <span style=color:#666>0</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            unparkSuccessor<span style=color:#666>(</span>h<span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>true</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>整个 release 做的事情就是</p><ol><li>调用 tryRelease</li><li>如果 tryRelease 返回 true 也就是独占锁被完全释放，唤醒后继线程。</li></ol><p>这里的唤醒是根据 head 几点来判断的，上面代码的注释中也分析了 head 节点的情况，只有在 head 存在并且等待状态小于零的情况下唤醒。</p><ul><li><code>tryRelease(int)</code>跟<code>tryAcquire()</code>一样，这个方法是需要自定义同步器去实现的。</li></ul><p>正常来说，<code>tryRelease()</code>都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可，也不需要考虑线程安全的问题。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>protected</span> <span style=color:#0b0;font-weight:700>boolean</span> <span style=color:#00a000>tryRelease</span><span style=color:#666>(</span><span style=color:#0b0;font-weight:700>int</span> arg<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>throw</span> <span style=color:#a2f;font-weight:700>new</span> UnsupportedOperationException<span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h2 id=获取共享锁的实现>获取共享锁的实现</h2><p>与获取独占锁的实现不同的关键在于，共享锁允许多个线程持有。</p><p>如果需要使用 AQS 中共享锁，在实现<code>tryAcquireShared(int)</code>方法时需要注意，返回负数表示获取失败；返回 0 表示成功，但是后继争用线程不会成功；返回正数表示获取成功，并且后继争用线程也可能成功。</p><ul><li><code>acquireShared(int)</code>此方法是共享模式下线程获取共享资源的顶层入口。</li></ul><p>它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>final</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>acquireShared</span><span style=color:#666>(</span><span style=color:#0b0;font-weight:700>int</span> arg<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>tryAcquireShared<span style=color:#666>(</span>arg<span style=color:#666>)</span> <span style=color:#666>&lt;</span> <span style=color:#666>0</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>        doAcquireShared<span style=color:#666>(</span>arg<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><ul><li><code>tryAcquireShared(int)</code>需要自定义同步器去实现。但是 AQS 已经把其返回值的语义定义好了：负值代表获取失败；0 代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>protected</span> <span style=color:#0b0;font-weight:700>int</span> <span style=color:#00a000>tryAcquireShared</span><span style=color:#666>(</span><span style=color:#0b0;font-weight:700>int</span> arg<span style=color:#666>)</span> <span style=color:#666>{</span> 
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>throw</span> <span style=color:#a2f;font-weight:700>new</span> UnsupportedOperationException<span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><ul><li><code>doAcquireShared(int)</code>功能类似于独占模式下的<code>acquireQueued()</code>。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>private</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>doAcquireShared</span><span style=color:#666>(</span><span style=color:#0b0;font-weight:700>int</span> arg<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>final</span> Node node <span style=color:#666>=</span> addWaiter<span style=color:#666>(</span>Node<span style=color:#666>.</span><span style=color:#b44>SHARED</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#0b0;font-weight:700>boolean</span> failed <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>true</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>try</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:#0b0;font-weight:700>boolean</span> interrupted <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>for</span> <span style=color:#666>(;;)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>final</span> Node p <span style=color:#666>=</span> node<span style=color:#666>.</span><span style=color:#b44>predecessor</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>						
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>p <span style=color:#666>==</span> head<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>								
</span></span><span style=display:flex><span>                <span style=color:#0b0;font-weight:700>int</span> r <span style=color:#666>=</span> tryAcquireShared<span style=color:#666>(</span>arg<span style=color:#666>);</span>
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>r <span style=color:#666>&gt;=</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>										
</span></span><span style=display:flex><span>                    setHeadAndPropagate<span style=color:#666>(</span>node<span style=color:#666>,</span> r<span style=color:#666>);</span>
</span></span><span style=display:flex><span>                    p<span style=color:#666>.</span><span style=color:#b44>next</span> <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>null</span><span style=color:#666>;</span> 
</span></span><span style=display:flex><span>                    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>interrupted<span style=color:#666>)</span>
</span></span><span style=display:flex><span>                        selfInterrupt<span style=color:#666>();</span>
</span></span><span style=display:flex><span>                    failed <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>                    <span style=color:#a2f;font-weight:700>return</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>                <span style=color:#666>}</span>
</span></span><span style=display:flex><span>            <span style=color:#666>}</span>
</span></span><span style=display:flex><span>						
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>shouldParkAfterFailedAcquire<span style=color:#666>(</span>p<span style=color:#666>,</span> node<span style=color:#666>)</span> <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>                parkAndCheckInterrupt<span style=color:#666>())</span>
</span></span><span style=display:flex><span>                interrupted <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>true</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span> <span style=color:#a2f;font-weight:700>finally</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>failed<span style=color:#666>)</span>
</span></span><span style=display:flex><span>            cancelAcquire<span style=color:#666>(</span>node<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>跟独占模式比，有一点需要注意的是，这里只有线程是<code>head.next</code>时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。</p><p>那么问题就来了，假如老大用完后释放了 5 个资源，而老二需要 6 个，老三需要 1 个，老四需要 2 个。因为老大先唤醒老二，老二一看资源不够自己用继续 park()，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。</p><ul><li><code>setHeadAndPropagate(Node, int)</code>函数用来设置新 head，并在一定情况下调用<code>doReleaseShared</code>。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>private</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>setHeadAndPropagate</span><span style=color:#666>(</span>Node node<span style=color:#666>,</span> <span style=color:#0b0;font-weight:700>int</span> propagate<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Node h <span style=color:#666>=</span> head<span style=color:#666>;</span>
</span></span><span style=display:flex><span>    setHead<span style=color:#666>(</span>node<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>propagate <span style=color:#666>&gt;</span> <span style=color:#666>0</span> <span style=color:#666>||</span> h <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>null</span> <span style=color:#666>||</span> h<span style=color:#666>.</span><span style=color:#b44>waitStatus</span> <span style=color:#666>&lt;</span> <span style=color:#666>0</span> <span style=color:#666>||</span>
</span></span><span style=display:flex><span>        <span style=color:#666>(</span>h <span style=color:#666>=</span> head<span style=color:#666>)</span> <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>null</span> <span style=color:#666>||</span> h<span style=color:#666>.</span><span style=color:#b44>waitStatus</span> <span style=color:#666>&lt;</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        Node s <span style=color:#666>=</span> node<span style=color:#666>.</span><span style=color:#b44>next</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>s <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>null</span> <span style=color:#666>||</span> s<span style=color:#666>.</span><span style=color:#b44>isShared</span><span style=color:#666>())</span>
</span></span><span style=display:flex><span>						
</span></span><span style=display:flex><span>            doReleaseShared<span style=color:#666>();</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>此方法在<code>setHead()</code>的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继节点，毕竟是共享模式。</p><h2 id=释放共享锁的实现>释放共享锁的实现</h2><ul><li><code>releaseShared(int)</code>共享模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即 state=0）, 它会唤醒等待队列里的其他线程来获取资源。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>public</span> <span style=color:#a2f;font-weight:700>final</span> <span style=color:#0b0;font-weight:700>boolean</span> <span style=color:#00a000>releaseShared</span><span style=color:#666>(</span><span style=color:#0b0;font-weight:700>int</span> arg<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>tryReleaseShared<span style=color:#666>(</span>arg<span style=color:#666>))</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>				
</span></span><span style=display:flex><span>        doReleaseShared<span style=color:#666>();</span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>true</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>false</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><ul><li><code>tryReleaseShared(int)</code></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>protected</span> <span style=color:#0b0;font-weight:700>boolean</span> <span style=color:#00a000>tryReleaseShared</span><span style=color:#666>(</span><span style=color:#0b0;font-weight:700>int</span> arg<span style=color:#666>)</span> <span style=color:#666>{</span> 
</span></span><span style=display:flex><span>		<span style=color:#a2f;font-weight:700>throw</span> <span style=color:#a2f;font-weight:700>new</span> UnsupportedOperationException<span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>跟独占模式下的<code>release()</code>相似，但有一点稍微需要注意：独占模式下的<code>tryRelease()</code>在完全释放掉资源（state=0）后，才会返回 true 去唤醒其他线程，这主要是基于可重入的考量；而共享模式下的<code>releaseShared()</code>则没有这种要求，多线程可并发执行，不适用于可重入。</p><ul><li><code>doReleaseShared()</code></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>private</span> <span style=color:#0b0;font-weight:700>void</span> <span style=color:#00a000>doReleaseShared</span><span style=color:#666>()</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> <span style=color:#666>(;;)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        Node h <span style=color:#666>=</span> head<span style=color:#666>;</span>
</span></span><span style=display:flex><span>				
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>h <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>null</span> <span style=color:#666>&amp;&amp;</span> h <span style=color:#666>!=</span> tail<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            <span style=color:#0b0;font-weight:700>int</span> ws <span style=color:#666>=</span> h<span style=color:#666>.</span><span style=color:#b44>waitStatus</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>ws <span style=color:#666>==</span> Node<span style=color:#666>.</span><span style=color:#b44>SIGNAL</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>								
</span></span><span style=display:flex><span>                <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(!</span>compareAndSetWaitStatus<span style=color:#666>(</span>h<span style=color:#666>,</span> Node<span style=color:#666>.</span><span style=color:#b44>SIGNAL</span><span style=color:#666>,</span> <span style=color:#666>0</span><span style=color:#666>))</span>
</span></span><span style=display:flex><span>                    <span style=color:#a2f;font-weight:700>continue</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>                unparkSuccessor<span style=color:#666>(</span>h<span style=color:#666>);</span>
</span></span><span style=display:flex><span>            <span style=color:#666>}</span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>ws <span style=color:#666>==</span> <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>                     <span style=color:#666>!</span>compareAndSetWaitStatus<span style=color:#666>(</span>h<span style=color:#666>,</span> <span style=color:#666>0</span><span style=color:#666>,</span> Node<span style=color:#666>.</span><span style=color:#b44>PROPAGATE</span><span style=color:#666>))</span>
</span></span><span style=display:flex><span>                <span style=color:#a2f;font-weight:700>continue</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>h <span style=color:#666>==</span> head<span style=color:#666>)</span>
</span></span><span style=display:flex><span>            <span style=color:#a2f;font-weight:700>break</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>除了上面分析的核心方法，AQS 还有定义了附带超时功能的<code>tryAcquireNanos()</code> 、<code>tryAcquireSharedNanos()</code>方法，以及响应中断的<code>acquireInterruptibly()</code> 、<code>acquireSharedInterruptibly()</code>方法，其核心流程与通用方法大同小异。</p><p><strong>Q1：<code>unparkSuccessor(Node)</code>方法中为什么唤醒后继节点时要从 tail 向前查找最接近 node 的非取消节点，而不是直接从 node 向后找到第一个后 break 掉?</strong></p><blockquote><p>答：如果读到 s == null（node.next），不代表 node 就为 tail。 考虑如下场景：</p></blockquote><ul><li>node 某时刻为 tail</li><li>有新线程通过 addWaiter 中的 if 分支或者 enq 方法添加自己</li><li>compareAndSetTail 成功</li><li>此时这里的 Node s = node.next 读出来 s == null，但事实上 node 已经不是 tail，它有后继了</li></ul><p>反过来，如果从 node 开始向后找后继，此时 node 的对象后继 node.next 为空，找不到后继。</p><p><strong>Q2：<code>unparkSuccessor(Node)</code>方法在被 release 调用时是否存在这样的一个漏洞?</strong></p><blockquote><p>答：unparkSuccessor 方法在被 release 调用时是否存在漏洞?</p></blockquote><ul><li>时刻 1: node -> tail && tail.waitStatus == Node.CANCELLED (node 的下一个节点为 tail，并且 tail 处于取消状态)</li><li>时刻 2: unparkSuccessor 读到 s.waitStatus > 0</li><li>时刻 3: unparkSuccessor 从 tail 开始遍历</li><li>时刻 4: tail 节点对应线程执行 cancelAcquire 方法中的 if (node == tail && compareAndSetTail(node, pred)) 返回 true，此时 tail 变为 pred(也就是 node)</li><li>时刻 5: 有新线程进队列 tail 变为新节点</li><li>时刻 6: unparkSuccessor 没有发现需要唤醒的节点</li></ul><p>最终新节点阻塞并且前驱节点结束调用，新节点再也无法被 unpark 这种情况不会发生, 确实可能出现从 tail 向前扫描，没有读到新入队的节点，但别忘了 acquireQueued 的思想就是不断循环检测是否能够独占获取锁， 否则再进行判断是否要阻塞自己，而 release 的第一步就是 tryRelease，它的语义为 true 表示完全释放独占锁，完全释放之后才会执行后面的逻辑，也就是 unpark 后继线程。在这种情况下，新入队的线程应当能获取到锁。 如果没有获取锁，则必然是在覆盖 tryAcquire/tryRelease 的实现有问题，导致前驱节点成功释放了独占锁，后继节点获取独占锁仍然失败。也就是说 AQS 框架的可靠性还在 某些程度上依赖于具体子类的实现，子类实现如果有 bug，那 AQS 再精巧也扛不住。</p><p><strong>Q3：AQS 如何保证在节点释放的同时又有新节点入队的情况下，不出现原持锁线程释放锁，后继线程被自己阻塞死的情况, 保持同步队列的活跃？</strong></p><blockquote><p>答：需要结合<code>shouldParkAfterFailedAcquire((Node, Node))</code>和<code>unparkSuccessor(Node)</code>这两个方法。以独占锁为例，后继争用线程阻塞自己的情况是读到前驱节点的等待状态为 SIGNAL, 只要不是这种情况都会再试着去争取锁。</p></blockquote><p>假设后继线程读到了前驱状态为 SIGNAL，说明之前在 tryAcquire 的时候，前驱持锁线程还没有 tryRelease 完全释放掉独占锁。</p><p>此时如果前驱线程完全释放掉了独占锁，则在 unparkSuccessor 中还没执行完置 waitStatus 为 0 的操作，也就是还没执行到下面唤醒后继线程的代码，否则后继线程会再去争取锁。</p><p>那么就算后继争用线程此时把自己阻塞了，也一定会马上被前驱线程唤醒。</p><p>那么是否可能持锁线程执行唤醒后继线程的逻辑时，后继线程读到前驱等待状态为 SIGNAL 把自己给阻塞，再也无法苏醒呢？</p><p>这个问题在上面的 Q2 中已经有答案了，确实可能在扫描后继需要唤醒线程时读不到新来的线程，但只要 tryRelease 语义实现正确，在 true 时表示完全释放独占锁，则后继线程理应能够 tryAcquire 成功，shouldParkAfterFailedAcquire 在读到前驱状态不为 SIGNAL 会给当前线程再一次获取锁的机会的。</p><p><strong>Q4：<code>addWaiter(Node)</code>和<code>enq(Node)</code>方法中新增一个节点时为什么要先将新节点的 prev 置为 tail 再尝试 CAS，而不是 CAS 成功后来构造节点之间的双向链接?</strong></p><blockquote><p>答：双向链表目前没有基于 CAS 原子插入的手段，如果我们将 node.prev = t 和 t.next = node（t 为方法执行时读到的 tail，引用封闭在栈上）放到 compareAndSetTail(t, node) 成功后执行，如下所示：</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>compareAndSetTail<span style=color:#666>(</span>t<span style=color:#666>,</span> node<span style=color:#666>))</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>   node<span style=color:#666>.</span><span style=color:#b44>prev</span> <span style=color:#666>=</span> t<span style=color:#666>;</span>
</span></span><span style=display:flex><span>   t<span style=color:#666>.</span><span style=color:#b44>next</span> <span style=color:#666>=</span> node<span style=color:#666>;</span>
</span></span><span style=display:flex><span>   <span style=color:#a2f;font-weight:700>return</span> t<span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><blockquote><p>会导致这一瞬间的 tail 也就是 t 的 prev 为 null，这就使得这一瞬间队列处于一种不一致的中间状态。</p></blockquote><p><strong>Q5：PROPAGATE 状态存在的意义</strong></p><blockquote><p>答：在 setHeadAndPropagate 中我们可以看到如下的一段代码</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>propagate <span style=color:#666>&gt;</span> <span style=color:#666>0</span> <span style=color:#666>||</span> h <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>null</span> <span style=color:#666>||</span> h<span style=color:#666>.</span><span style=color:#b44>waitStatus</span> <span style=color:#666>&lt;</span> <span style=color:#666>0</span> <span style=color:#666>||</span>
</span></span><span style=display:flex><span>       <span style=color:#666>(</span>h <span style=color:#666>=</span> head<span style=color:#666>)</span> <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>null</span> <span style=color:#666>||</span> h<span style=color:#666>.</span><span style=color:#b44>waitStatus</span> <span style=color:#666>&lt;</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>       Node s <span style=color:#666>=</span> node<span style=color:#666>.</span><span style=color:#b44>next</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>       <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>s <span style=color:#666>==</span> <span style=color:#a2f;font-weight:700>null</span> <span style=color:#666>||</span> s<span style=color:#666>.</span><span style=color:#b44>isShared</span><span style=color:#666>())</span>
</span></span><span style=display:flex><span>           doReleaseShared<span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><blockquote><p>在 PROPAGATE 引入之前，之所以可能会出现线程 hang 住的情况，就是在于 releaseShared 有竞争的情况下，可能会有队列中处于等待状态的节点因为第一个线程完成释放唤醒，第二个线程获取到锁，但还没设置好 head，又有新线程释放锁，但是读到老的 head 状态为 0 导致释放但不唤醒，最终后一个等待线程既没有被释放线程唤醒，也没有被持锁线程唤醒。</p></blockquote><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>ws <span style=color:#666>==</span> Node<span style=color:#666>.</span><span style=color:#b44>SIGNAL</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>	  <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(!</span>compareAndSetWaitStatus<span style=color:#666>(</span>h<span style=color:#666>,</span> Node<span style=color:#666>.</span><span style=color:#b44>SIGNAL</span><span style=color:#666>,</span> <span style=color:#666>0</span><span style=color:#666>))</span>
</span></span><span style=display:flex><span>	      <span style=color:#a2f;font-weight:700>continue</span><span style=color:#666>;</span>            
</span></span><span style=display:flex><span>	  unparkSuccessor<span style=color:#666>(</span>h<span style=color:#666>);</span>
</span></span><span style=display:flex><span>	<span style=color:#666>}</span>
</span></span><span style=display:flex><span>	<span style=color:#a2f;font-weight:700>else</span> <span style=color:#a2f;font-weight:700>if</span> <span style=color:#666>(</span>ws <span style=color:#666>==</span> <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>	       <span style=color:#666>!</span>compareAndSetWaitStatus<span style=color:#666>(</span>h<span style=color:#666>,</span> <span style=color:#666>0</span><span style=color:#666>,</span> Node<span style=color:#666>.</span><span style=color:#b44>PROPAGATE</span><span style=color:#666>))</span>
</span></span><span style=display:flex><span>	  <span style=color:#a2f;font-weight:700>continue</span><span style=color:#666>;</span>                
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p><strong>Q6：AQS 维护了一个 FIFO 队列，它是如何保证在运行期间不发生内存泄露的？</strong></p><blockquote><p>AQS 在无竞争条件下，甚至都不会 new 出 head 和 tail 节点。</p></blockquote><p>线程成功获取锁时设置 head 节点的方法为<code>setHead</code>，由于头节点的 thread 并不重要，此时会置<code>node</code>的 thread 和<code>prev</code>为 null，完了之后还会置原先<code>head</code>也就是线程对应<code>node</code>的前驱的<code>next</code>为 null，从而实现队首元素的安全移出。</p><p>而在取消节点时，也会令<code>node.thread = null</code>，在<code>node</code>不为<code>tail</code>的情况下，会使<code>node.next = node</code>（之所以这样也是为了 isOnSyncQueue 实现更加简洁）</p></div><footer class=post-footer><div class=post-tags><a href=/tags/java rel=tag title=Java>#Java#</a>
<a href=/tags/%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b rel=tag title=并发编程>#并发编程#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>QQ扫一扫交流</div></div><div class=article-copyright-info><p><span>标题：</span>AQS详解</p><p><span>链接：</span>https://codingroam.github.io/post/aqs%E8%AF%A6%E8%A7%A3/</p><p><span>作者：</span>roam</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://codingroam.github.io/post/springboot+springcache+redis%E6%95%B4%E5%90%88/ rel=next title=SpringBoot+SpringCache+Redis整合><i class="fa fa-chevron-left"></i> SpringBoot+SpringCache+Redis整合</a></div><div class="post-nav-prev post-nav-item"><a href=https://codingroam.github.io/post/%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E9%97%AE%E9%A2%98/ rel=prev title=日志记录报错堆栈问题>日志记录报错堆栈问题
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.png alt=roam><p class=site-author-name itemprop=name>roam</p><p class="site-description motion-element" itemprop=description>以为打得赢我啊你</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>78</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>30</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>54</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/wk123456/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://www.zhihu.com/ target=_blank title=知乎><i class="fa fa-fw fa-globe"></i>
知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class=links-of-blogroll-title><i class="fa fa-fw fa-globe"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://nutzam.com/ title=Nutz target=_blank>Nutz</a></li><li class=links-of-blogroll-item><a href=https://jfinal.com/ title=JFinal target=_blank>JFinal</a></li><li class=links-of-blogroll-item><a href=http://wendal.net/ title=Wendal target=_blank>Wendal</a></li><li class=links-of-blogroll-item><a href=https://www.liaoxuefeng.com/ title=廖雪峰 target=_blank>廖雪峰</a></li></ul></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/learning>Learning
<sup>27</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/mysql>Mysql
<sup>12</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/java>Java
<sup>11</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6>中间件
<sup>10</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/golang>Golang
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/golang%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0>Golang编程学习
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/linux>Linux
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/redis>Redis
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/problem-solving>Problem solving
<sup>7</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/docker>Docker
<sup>6</sup></a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>想学啊你</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.115.4</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=https://gitee.com/ style=font-weight:700 target=_blank>Gitee 仓库</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href=http://beian.miit.gov.cn target=_blank>粤 ICP 备 18047355 号</a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//unpkg.com/jquery@2.1.4/dist/jquery.min.js></script>
<script type=text/javascript src=https://codingroam.github.io/js/search.js></script>
<script type=text/javascript src=https://codingroam.github.io/js/affix.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".footer").outerHeight(!0),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var e,t,n,s,o=$(".header-inner").height()+10;$("#sidebar").css({"margin-top":o}).show(),t=parseInt($("#sidebar").css("margin-top")),n=parseInt($(".sidebar-inner").css("height")),e=t+n,s=$(".content-wrap").height(),s<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script type=text/javascript>const locale={placeholder:"欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^"};$(function(){detectIE()>0?$.getScript(document.location.protocol+"//unpkg.com/@waline/client@1.6.0/dist/Waline.min.js",function(){new Waline({el:"#wcomments",visitor:!0,emoji:[],wordLimit:"200",uploadImage:!1,locale,requiredMeta:["nick","mail"],serverURL:"Your WalineSerURL",lang:"zh-cn"})}):$("#wcomments").html("抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。")})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script>
<script>(function(){var t,e=document.createElement("script"),n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>