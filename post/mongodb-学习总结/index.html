<!doctype html><html lang=zh-cn dir=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>MongoDB学习总结 - 想学啊你</title><meta name=keywords content="博客"><meta name=author content="roam"><meta property="og:title" content="MongoDB学习总结"><meta property="og:site_name" content="想学啊你"><meta property="og:image" content="https://codingroam.github.io/img/author.jpg"><meta name=title content="MongoDB学习总结 - 想学啊你"><meta name=description content="轻轻的你来了"><link rel="shortcut icon" href=https://codingroam.github.io/img/favicon.ico><link rel=apple-touch-icon href=https://codingroam.github.io/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://codingroam.github.io/img/apple-touch-icon.png><link href=//unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.css rel=stylesheet><link href=https://codingroam.github.io/css/main.css rel=stylesheet type=text/css><link href=https://codingroam.github.io/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-Hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>想学啊你</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>三四楼那么高了</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-active"><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/tags rel=section><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class=menu-item><a href=/categories rel=section><i class="menu-item-icon fa fa-fw fa-book"></i><br>分类</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://codingroam.github.io/post/mongodb-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/ itemprop=url>MongoDB学习总结</a></h1><div class=post-meta><span class=post-pushdate><i class="fa fa-calendar-o fa-fw"></i>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2023-08-27">2023-08-27</time></span>
<span class=post-category><i class="fa fa-folder-o fa-fw"></i>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/mongodb itemprop=url rel=index><span itemprop=name>MongoDB</span></a>
&nbsp;</span></span>
<span class=post-wordcount><i class="fa fa-file-word-o fa-fw"></i>
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>7323 字</span></span>
<span class=post-readtime><i class="fa fa-eye fa-fw"></i>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>15分钟</span></span>
<span id=/post/mongodb-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/ class="leancloud_visitors post-visitor" data-flag-title=MongoDB学习总结><i class="fa fa-binoculars fa-fw"></i>
<span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>MongoDB学习总结</p><h2 id=一简介><strong>一、简介</strong></h2><p>MongoDB 是一款流行的开源文档型数据库，从它的命名来看，确实是有一定野心的。<br>MongoDB 的原名一开始<strong>来自于 英文单词 &ldquo;Humongous&rdquo;, 中文含义是指 &ldquo;庞大&rdquo;</strong>，即命名者的意图是可以处理大规模的数据。</p><p>但笔者更喜欢称呼它为 &ldquo;芒果&rdquo; 数据库，除了译音更加相近之外，原因还来自于这几年使用 MongoDB 的两层感觉：</p><ul><li>第一层感受是 &ldquo;爽&rdquo;，使用这个文档数据库的特点是几乎不受什么限制，一方面 Json 文档式的结构更容易理解，而无 Schema 约束也让 DDL 管理更加简单，一切都可以很快速的进行。</li><li>第二层感受是 &ldquo;酸爽&rdquo;，这点相信干运维或是支撑性工作的兄弟感受会比较深刻，MongoDB 由于入门体验 &ldquo;太过于友好&rdquo;，导致一些团队认为用好这个数据库是个很简单的事情，所以开发兄弟在存量系统上埋一些坑也是正常的事情。<br>所谓交付一时爽，维护火葬场.. 当然了，这句话可能有些过。 但这里的潜台词是：与传统的 RDBMS 数据库一样，MongoDB 在使用上也需要认真的考量和看护，不然的化，会遇到更多的坑。</li></ul><p>那么，尽管文档数据库在选型上会让一些团队望而却步，仍然不阻碍该数据库所获得的一些支持，比如 DB-Engine 上的排名：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-aedbdb7187c091f3b2e091baea945806_r.jpg alt></p><p>图 - DBEngine 排名</p><p>在全部的排名中，MongoDB 长期排在第 5 位 (文档数据库排名第 1 位)，同时也是最受欢迎的 NoSQL 数据库。<br>另外，MongoDB 的社区一直比较活跃，加上商业上的驱动 (MongoDB 于 2017 年在纳斯达克上市)，这些因素都推动了该开源数据库的发展。</p><p>如果对于 MongoDB 的发展史感兴趣，可以参考下<a href="https://link.zhihu.com/?target=https%3A//www.infoq.cn/article/XBME_sTIRA5fA8NDCaGj" target=_blank rel=noopener>没有一个技术天生完美，MongoDB 十年发展全纪录</a>
这篇文章。</p><p>MongoDB 数据库的一些特性：</p><ul><li>面向文档存储，基于 JSON/BSON 可表示灵活的数据结构</li><li>动态 DDL 能力，没有强 Schema 约束，支持快速迭代</li><li>高性能计算，提供基于内存的快速数据查询</li><li>容易扩展，利用数据分片可以支持海量数据存储</li><li>丰富的功能集，支持二级索引、强大的聚合管道功能，为开发者量身定做的功能，如数据自动老化、固定集合等等。</li><li>跨平台版本、支持多语言 SDK..</li></ul><p>假定你是初次了解 MongoDB，下面的内容将能帮助你对该数据库技术的全貌产生一定的了解。</p><h2 id=二基本模型><strong>二、基本模型</strong></h2><p>数据结构对于一个软件来说是至关重要的，MongoDB 在概念模型上参考了 SQL 数据库，但并非完全相同。</p><blockquote><p>关于这点，也有人说，MongoDB 是 NoSQL 中最像 SQL 的数据库..</p></blockquote><p>如下表所示：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-23df3200d4d576f29060c934e51abad2_b.jpg alt></p><ul><li>database 数据库，与 SQL 的数据库 (database) 概念相同，一个数据库包含多个集合(表)</li><li>collection 集合，相当于 SQL 中的表 (table)，一个集合可以存放多个文档(行)。 不同之处就在于集合的结构(schema) 是动态的，不需要预先声明一个严格的表结构。更重要的是，默认情况下 MongoDB 并不会对写入的数据做任何 schema 的校验。</li><li>document 文档，相当于 SQL 中的行 (row)，一个文档由多个字段(列) 组成，并采用 bson(json)格式表示。</li><li>field 字段，相当于 SQL 中的列 (column)，相比普通 column 的差别在于 field 的类型可以更加灵活，比如支持嵌套的文档、数组。<br>此外，MongoDB 中字段的类型是固定的、区分大小写、并且文档中的字段也是有序的。</li></ul><p>另外，SQL 还有一些其他的概念，对应关系如下：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-4a4ce8ff9c69d5402f70baa1b050ad0d_b.jpg alt></p><ul><li>_id 主键，MongoDB 默认使用一个_id 字段来保证文档的唯一性。</li><li>reference 引用，勉强可以对应于 外键 (foreign key) 的概念，之所以是勉强是因为 reference 并没有实现任何外键的约束，而只是由客户端(driver) 自动进行关联查询、转换的一个特殊类型。</li><li>view 视图，MongoDB 3.4 开始支持视图，和 SQL 的视图没有什么差异，视图是基于表 / 集合之上进行动态查询的一层对象，可以是虚拟的，也可以是物理的 (物化视图)。</li><li>index 索引，与 SQL 的索引相同。</li><li>$lookup，这是一个聚合操作符，可以用于实现类似 SQL-join 连接的功能</li><li>transaction 事务，从 MongoDB 4.0 版本开始，提供了对于事务的支持</li><li>aggregation 聚合，MongoDB 提供了强大的聚合计算框架，group by 是其中的一类聚合操作。</li></ul><h3 id=bson-数据类型><strong>BSON 数据类型</strong></h3><p>MongoDB 文档可以使用 Javascript 对象表示，从格式上讲，是基于 JSON 的。</p><p>一个典型的文档如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>{
</span></span><span style=display:flex><span>  &#34;_id&#34;: 1,
</span></span><span style=display:flex><span>  &#34;name&#34; : { &#34;first&#34; : &#34;John&#34;, &#34;last&#34; : &#34;Backus&#34; },
</span></span><span style=display:flex><span>  &#34;contribs&#34; : [ &#34;Fortran&#34;, &#34;ALGOL&#34;, &#34;Backus-Naur Form&#34;, &#34;FP&#34; ],
</span></span><span style=display:flex><span>  &#34;awards&#34; : [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      &#34;award&#34; : &#34;W.W. McDowell Award&#34;,
</span></span><span style=display:flex><span>      &#34;year&#34; : 1967,
</span></span><span style=display:flex><span>      &#34;by&#34; : &#34;IEEE Computer Society&#34;
</span></span><span style=display:flex><span>    }, {
</span></span><span style=display:flex><span>      &#34;award&#34; : &#34;Draper Prize&#34;,
</span></span><span style=display:flex><span>      &#34;year&#34; : 1993,
</span></span><span style=display:flex><span>      &#34;by&#34; : &#34;National Academy of Engineering&#34;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>曾经，JSON 的出现及流行让 Web 2.0 的数据传输变得非常简单，所以使用 JSON 语法是非常容易让开发者接受的。<br>但是 JSON 也有自己的短板，比如无法支持像日期这样的特定数据类型，因此 MongoDB 实际上使用的是一种扩展式的 JSON，叫 BSON(Binary JSON)。</p><p>BSON 所支持的数据类型包括：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-d4a8d94cd6a79ed0b49524dffa7a1e88_r.jpg alt></p><p>图 - BSON 类型</p><h3 id=分布式-id><strong>分布式 ID</strong></h3><p>在单机时代，大多数应用可以使用数据库自增式 ID 来作为主键。 传统的 RDBMS 也都支持这种方式，比如 mysql 可以通过声明 auto_increment 来实现自增的主键。 但一旦数据实现了分布式存储，这种方式就不再适用了，原因就在于无法保证多个节点上的主键不出现重复。</p><p>为了实现分布式数据 ID 的唯一性保证，应用开发者提出了自己的方案，而大多数方案中都会将 ID 分段生成，如著名的 snowflake 算法中就同时使用了时间戳、机器号、进程号以及随机数来保证唯一性。</p><p>MongoDB 采用 ObjectId 来表示主键的类型，数据库中每个文档都拥有一个_id 字段表示主键。<br>_id 的生成规则如下：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-227bd6ae2f8a3c05546f51cfd4a0b7a8_b.jpg alt></p><p>图 - ObjecteID</p><p>其中包括：</p><ul><li>4-byte Unix 时间戳</li><li>3-byte 机器 ID</li><li>2-byte 进程 ID</li><li>3-byte 计数器 (初始化随机)</li></ul><p>值得一提的是 _id 的生成实质上是由客户端 (Driver) 生成的，这样可以获得更好的随机性，同时降低服务端的负载。<br>当然服务端也会检测写入的文档是否包含_id 字段，如果没有就生成一个。</p><h2 id=三操作语法><strong>三、操作语法</strong></h2><p>除了文档模型本身，对于数据的操作命令也是基于 JSON/BSON 格式的语法。</p><p>比如插入文档的操作：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span>db.book.insert(</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span>title:</span> <span style=color:green;font-weight:700>&#34;My first blog post&#34;</span>,
</span></span><span style=display:flex><span>  <span>published:</span> <span>new</span> <span>Date(),</span>
</span></span><span style=display:flex><span>  <span>tags:</span> <span>[</span> <span style=color:green;font-weight:700>&#34;NoSQL&#34;</span>, <span style=color:green;font-weight:700>&#34;MongoDB&#34;</span> <span>]</span>,
</span></span><span style=display:flex><span>  <span>type:</span> <span style=color:green;font-weight:700>&#34;Work&#34;</span>,
</span></span><span style=display:flex><span>  <span>author</span> <span>:</span> <span style=color:green;font-weight:700>&#34;James&#34;</span>,
</span></span><span style=display:flex><span>  <span>viewCount:</span> <span>25,</span>
</span></span><span style=display:flex><span>  <span>commentCount:</span> <span>2</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span>)</span>
</span></span></code></pre></div><p>执行文档查找：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span>db.book.find(</span>{<span>author</span> <span>:</span> <span style=color:green;font-weight:700>&#34;James&#34;</span>}<span>)</span>
</span></span></code></pre></div><p>更新文档的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span>db.book.update(</span>
</span></span><span style=display:flex><span>   {<span style=color:green;font-weight:700>&#34;_id&#34;</span> : <span>ObjectId(</span><span style=color:#b44>&#34;5c61301c15338f68639e6802&#34;</span><span>)</span>}<span>,</span>
</span></span><span style=display:flex><span>   {<span style=color:green;font-weight:700>&#34;$inc&#34;</span>: {<span style=color:green;font-weight:700>&#34;viewCount&#34;</span>: <span style=color:#666>3</span>} }
</span></span><span style=display:flex><span><span>)</span>
</span></span></code></pre></div><p>删除文档的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span>db.book.remove(</span>{<span style=color:green;font-weight:700>&#34;_id&#34;</span>:
</span></span><span style=display:flex><span>     <span>ObjectId(</span><span style=color:#b44>&#34;5c612b2f15338f68639e67d5&#34;</span><span>)</span>}<span>)</span>
</span></span></code></pre></div><p>在传统的 SQL 语法中，可以限定返回的字段，MongoDB 可以使用 Projection 来表示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span>db.book.find(</span>{<span style=color:green;font-weight:700>&#34;author&#34;</span>: <span style=color:#b44>&#34;James&#34;</span>}<span>,</span> 
</span></span><span style=display:flex><span>    {<span style=color:green;font-weight:700>&#34;_id&#34;</span>: <span style=color:#666>1</span>, <span style=color:green;font-weight:700>&#34;title&#34;</span>: <span style=color:#666>1</span>, <span style=color:green;font-weight:700>&#34;author&#34;</span>: <span style=color:#666>1</span>}<span>)</span>
</span></span></code></pre></div><p>实现简单的分页查询：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span>db.book.find(</span>{}<span>)</span>
</span></span><span style=display:flex><span>    <span>.sort(</span>{<span style=color:green;font-weight:700>&#34;viewCount&#34;</span> : <span style=color:#666>-1</span>}<span>)</span>
</span></span><span style=display:flex><span>    <span>.skip(</span><span style=color:#666>10</span><span>).limit(</span><span style=color:#666>5</span><span>)</span>
</span></span></code></pre></div><p>这种基于 BSON/JSON 的语法格式并不复杂，它的表达能力或许要比 SQL 更加强大。<br>与 MongoDB 做法类似的还有 ElasticSearch，后者是搜索数据库的佼佼者。</p><p>关于文档操作与 SQL 方式完整的对比，官方的文档描述得比较详细：<br><a href="https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/reference/sql-comparison/" target=_blank rel=noopener>https://docs.mongodb.com/manual/reference/sql-comparison/</a></p><p>那么，一个有趣的问题是 MongoDB 能不能用 SQL 进行查询？</p><p>当然是可以！</p><p>但需要注意这些功能并不是 MongoDB 原生自带的，而需要借由第三方工具平台实现：</p><ul><li>客户端使用 SQL，可以使用 mongobooster、studio3t 这样的工具</li><li>服务端的话，可以看看 presto 之类的一些平台..</li></ul><h2 id=四索引><strong>四、索引</strong></h2><p>无疑，索引是一个数据库的关键能力，MongoDB 支持非常丰富的索引类型。<br>利用这些索引，可以实现快速的数据查找，而索引的类型和特性则是针对不同的应用场景设计的。</p><p>索引的技术实现依赖于底层的存储引擎，在当前的版本中 MongoDB 使用 wiredTiger 作为默认的引擎。<br>在索引的实现上使用了 B + 树的结构，这与其他的传统数据库并没有什么不同。<br>所以这是个好消息，<strong>大部分基于 SQL 数据库的一些索引调优技巧在 MongoDB 上仍然是可行的</strong>。</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-c24f8bf90116e9396b14f56963ff8d03_r.jpg alt></p><p>图 - B + 树</p><p>使用 ensureIndexes 可以为集合声明一个普通的索引：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span>db.book.ensureIndex(</span>{<span>author:</span> <span>1</span>}<span>)</span>
</span></span></code></pre></div><blockquote><p>author 后面的数字 1 代表升序，如果是降序则是 -1</p></blockquote><p>实现复合式 (compound) 的索引，如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span>db.book.ensureIndex(</span>{<span>type:</span> <span>1,</span> <span>published:</span> <span>1</span>}<span>)</span>
</span></span></code></pre></div><blockquote><p>只有对于复合式索引时，索引键的顺序才变得有意义</p></blockquote><p>如果索引的字段是数组类型，该索引就自动成为数组 (multikey) 索引：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span>db.book.ensureIndex(</span>{<span>tags:</span> <span>1</span>}<span>)</span>
</span></span></code></pre></div><blockquote><p>MongoDB 可以在复合索引上包含数组的字段，但最多只能包含一个</p></blockquote><h3 id=索引特性><strong>索引特性</strong></h3><p>在声明索引时，还可以通过一些参数化选项来为索引赋予一定的特性，包括：</p><ul><li>unique=true，表示一个唯一性索引</li><li>expireAfterSeconds=3600，表示这是一个 TTL 索引，并且数据将在 1 小时后老化</li><li>sparse=true，表示稀疏的索引，仅索引非空 (non-null) 字段的文档</li><li>partialFilterExpression: {rating: { $gt: 5}，条件式索引，即满足计算条件的文档才进行索引</li></ul><h3 id=索引分类><strong>索引分类</strong></h3><p>除了普通索引之外，MongoDB 支持的类型还包括：</p><ul><li>哈希 (HASH) 索引，哈希是另一种快速检索的数据结构，MongoDB 的 HASH 类型分片键会使用哈希索引。</li><li>地理空间索引，用于支持快速的地理空间查询，如寻找附近 1 公里的商家。</li><li>文本索引，用于支持快速的全文检索</li><li>模糊索引 (Wildcard Index)，一种基于匹配规则的灵活式索引，在 4.2 版本开始引入。</li></ul><h3 id=索引评估调优><strong>索引评估、调优</strong></h3><p>使用 explain() 命令可以用于查询计划分析，进一步评估索引的效果。<br>如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>&gt; db.test.explain().find( { a : 5 } )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  &#34;queryPlanner&#34; : {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    &#34;winningPlan&#34; : {
</span></span><span style=display:flex><span>      &#34;stage&#34; : &#34;FETCH&#34;,
</span></span><span style=display:flex><span>      &#34;inputStage&#34; : {
</span></span><span style=display:flex><span>        &#34;stage&#34; : &#34;IXSCAN&#34;,
</span></span><span style=display:flex><span>        &#34;keyPattern&#34; : {
</span></span><span style=display:flex><span>            &#34;a&#34; : 5
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        &#34;indexName&#34; : &#34;a_1&#34;,
</span></span><span style=display:flex><span>        &#34;isMultiKey&#34; : false,
</span></span><span style=display:flex><span>        &#34;direction&#34; : &#34;forward&#34;,
</span></span><span style=display:flex><span>        &#34;indexBounds&#34; : {&#34;a&#34; : [&#34;[5.0, 5.0]&#34;]}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }},
</span></span><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从结果 winningPlan 中可以看出执行计划是否高效，比如：</p><ul><li>未能命中索引的结果，会显示 COLLSCAN</li><li>命中索引的结果，使用 IXSCAN</li><li>出现了内存排序，显示为 SORT</li></ul><p>关于 explain 的结果说明，可以进一步参考文档：</p><p><a href="https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/reference/explain-results/index.html" target=_blank rel=noopener>https://docs.mongodb.com/manual/reference/explain-results/index.html</a></p><h2 id=五集群><strong>五、集群</strong></h2><p>在大数据领域常常提到的 4V 特征中，Volume(数据量大) 是首当其冲被提及的。<br>由于单机垂直扩展能力的局限，水平扩展的方式则显得更加的靠谱。 MongoDB 自带了这种能力，可以将数据存储到多个机器上以提供更大的容量和负载能力。<br>此外，同时为了保证数据的高可用，MongoDB 采用副本集的方式来实现数据复制。</p><p>一个典型的 MongoDB 集群架构会同时采用分片 + 副本集的方式，如下图：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-6f849c75bffb439f06e9ceafe6263377_r.jpg alt></p><p>图 - MongoDB 分片集群 (Shard Cluster)</p><p><strong>架构说明</strong></p><ul><li>数据分片（Shards）<br>分片用于存储真正的集群数据，可以是一个单独的 Mongod 实例，也可以是一个副本集。 生产环境下 Shard 一般是一个 Replica Set，以防止该数据片的单点故障。<br>对于分片集合 (sharded collection) 来说，每个分片上都存储了集合的一部分数据(按照分片键切分)，如果集合没有分片，那么该集合的数据都存储在数据库的 Primary Shard 中。</li><li>配置服务器（Config Servers）<br>保存集群的元数据（metadata），包含各个 Shard 的路由规则，配置服务器由一个副本集 (ReplicaSet) 组成。</li><li>查询路由（Query Routers）<br>Mongos 是 Sharded Cluster 的访问入口，其本身并不持久化数据 。Mongos 启动后，会从 Config Server 加载元数据，开始提供服务，并将用户的请求正确路由到对应的 Shard。<br>Sharding 集群可以部署多个 Mongos 以分担客户端请求的压力。</li></ul><h3 id=分片机制><strong>分片机制</strong></h3><p>下面的几个细节，对于理解和应用 MongoDB 的分片机制比较重要，所以有必要提及一下：</p><p><strong>1. 数据如何切分</strong></p><p>首先，基于分片切分后的数据块称为 chunk，一个分片后的集合会包含多个 chunk，每个 chunk 位于哪个分片 (Shard) 则记录在 Config Server(配置服务器) 上。<br>Mongos 在操作分片集合时，会自动根据分片键找到对应的 chunk，并向该 chunk 所在的分片发起操作请求。</p><p><strong>数据是根据分片策略来进行切分的，而分片策略则由 分片键 (ShardKey)+ 分片算法(ShardStrategy) 组成。</strong></p><p>MongoDB 支持两种分片算法：</p><ul><li>范围分片</li></ul><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-4a9c8b977f026d13650d5fd70818d280_r.jpg alt></p><p>如上图所示，假设集合根据 x 字段来分片，x 的取值范围为 [minKey, maxKey]（x 为整型，这里的 minKey、maxKey 为整型的最小值和最大值），将整个取值范围划分为多个 chunk，每个 chunk（默认配置为 64MB）包含其中一小段的数据：<br>如 Chunk1 包含 x 的取值在 [minKey, -75) 的所有文档，而 Chunk2 包含 x 取值在 [-75, 25) 之间的所有文档&mldr;</p><p>范围分片能很好的满足<strong>范围查询</strong>的需求，比如想查询 x 的值在 [-30, 10] 之间的所有文档，这时 Mongos 直接能将请求路由到 Chunk2，就能查询出所有符合条件的文档。 范围分片的缺点在于，如果 ShardKey 有明显递增（或者递减）趋势，则新插入的文档多会分布到同一个 chunk，无法扩展写的能力，比如使用_id 作为 ShardKey，而 MongoDB 自动生成的 id 高位是时间戳，是持续递增的。</p><ul><li>哈希分片</li></ul><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-6beb0f8fd6e84d4ffa847d7a579bf1e7_r.jpg alt></p><p>Hash 分片是根据用户的 ShardKey 先计算出 hash 值（64bit 整型），再根据 hash 值按照<strong>范围分片</strong>的策略将文档分布到不同的 chunk。<br>由于 hash 值的计算是随机的，因此 Hash 分片具有很好的离散性，可以将数据随机分发到不同的 chunk 上。 Hash 分片可以充分的扩展写能力，弥补了范围分片的不足，但不能高效的服务范围查询，所有的范围查询要查询多个 chunk 才能找出满足条件的文档。</p><p><strong>2. 如何保证均衡</strong></p><p>如前面的说明中，数据是分布在不同的 chunk 上的，而 chunk 则会分配到不同的分片上，那么如何保证分片上的 数据 (chunk) 是均衡的呢？<br>在真实的场景中，会存在下面两种情况：</p><ul><li>A. 全预分配，chunk 的数量和 shard 都是预先定义好的，比如 10 个 shard，存储 1000 个 chunk，那么每个 shard 分别拥有 100 个 chunk。<br>此时集群已经是均衡的状态 (这里假定)</li><li>B. 非预分配，这种情况则比较复杂，一般当一个 chunk 太大时会产生分裂 (split)，不断分裂的结果会导致不均衡；或者动态扩容增加分片时，也会出现不均衡的状态。 这种不均衡的状态由集群均衡器进行检测，一旦发现了不均衡则执行 chunk 数据的搬迁达到均衡。</li></ul><p>MongoDB 的数据均衡器运行于 Primary Config Server(配置服务器的主节点) 上，而该节点也同时会控制 Chunk 数据的搬迁流程。</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-ecb42a8acff963eacb2463f56d51465b_r.jpg alt></p><p>图 - 数据自动均衡</p><p>对于数据的不均衡是根据两个分片上的 Chunk 个数差异来判定的，阈值对应表如下：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-a4afc0f479a98f4d8fa6302159dd5d4b_b.jpg alt></p><p>MongoDB 的数据迁移对集群性能存在一定影响，这点无法避免，目前的规避手段只能是将<a href="https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/tutorial/manage-sharded-cluster-balancer/%23sharding-schedule-balancing-window" target=_blank rel=noopener>均衡窗口</a>
对齐到业务闲时段。</p><p><strong>3. 应用高可用</strong></p><p>应用节点可以通过同时连接多个 Mongos 来实现高可用，如下：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-02b6729e1ae7d867e243c30524278a29_r.jpg alt></p><p>图 - mongos 高可用</p><p>当然，连接高可用的功能是由 Driver 实现的。</p><h3 id=副本集><strong>副本集</strong></h3><p>副本集又是另一个话题，实质上除了前面架构图所体现的，副本集可以作为 Shard Cluster 中的一个 Shard(片) 之外，对于规模较小的业务来说，也可以使用一个单副本集的方式进行部署。<br>MongoDB 的副本集采取了一主多从的结构，即一个 Primary Node + N* Secondary Node 的方式，数据从主节点写入，并复制到多个备节点。</p><p>典型的架构如下：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-69646e694e88aafce80498990307df9b_r.jpg alt></p><p>利用副本集，我们可以实现：：</p><ul><li>数据库高可用，主节点宕机后，由备节点自动选举成为新的主节点；</li><li>读写分离，读请求可以分流到备节点，减轻主节点的单点压力。</li></ul><p>请注意，读写分离只能增加集群 &ldquo;读&rdquo; 的能力，对于写负载非常高的情况却无能为力。<br>对此需求，使用分片集群并增加分片，或者提升数据库节点的磁盘 IO、CPU 能力可以取得一定效果。</p><p><strong>选举</strong></p><p>MongoDB 副本集通过 Raft 算法来完成主节点的选举，这个环节在初始化的时候会自动完成，如下面的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span>config</span> <span>=</span> {
</span></span><span style=display:flex><span>    <span>_id</span> <span>:</span> <span style=color:green;font-weight:700>&#34;my_replica_set&#34;</span>,
</span></span><span style=display:flex><span>    <span>members</span> <span>:</span> <span>[</span>
</span></span><span style=display:flex><span>        <span>{_id</span> <span>:</span> <span>0,</span> <span>host</span> <span>:</span> <span style=color:green;font-weight:700>&#34;rs1.example.net:27017&#34;</span>}<span>,</span>
</span></span><span style=display:flex><span>        {<span>_id</span> <span>:</span> <span>1,</span> <span>host</span> <span>:</span> <span style=color:green;font-weight:700>&#34;rs2.example.net:27017&#34;</span>}<span>,</span>
</span></span><span style=display:flex><span>        {<span>_id</span> <span>:</span> <span>2,</span> <span>host</span> <span>:</span> <span style=color:green;font-weight:700>&#34;rs3.example.net:27017&#34;</span>}<span>,</span>
</span></span><span style=display:flex><span>  <span>]</span>
</span></span><span style=display:flex><span><span>}</span>
</span></span><span style=display:flex><span><span>rs.initiate(config)</span>
</span></span></code></pre></div><p>initiate 命令用于实现副本集的初始化，在选举完成后，通过 isMaster() 命令就可以看到选举的结果：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span>&gt;</span> <span>db.isMaster()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;hosts&#34;</span> : [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;192.168.100.1:27030&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;192.168.100.2:27030&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;192.168.100.3:27030&#34;</span>
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;setName&#34;</span> : <span style=color:#b44>&#34;myReplSet&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;setVersion&#34;</span> : <span style=color:#666>1</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ismaster&#34;</span> : <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;secondary&#34;</span> : <span style=color:#a2f;font-weight:700>false</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;primary&#34;</span> : <span style=color:#b44>&#34;192.168.100.1:27030&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;me&#34;</span> : <span style=color:#b44>&#34;192.168.100.1:27030&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;electionId&#34;</span> : <span>ObjectId(</span><span style=color:#b44>&#34;7fffffff0000000000000001&#34;</span><span>)</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ok&#34;</span> : <span style=color:#666>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>受 Raft 算法的影响，主节点的选举需要满足 &ldquo;大多数&rdquo; 原则，可以参考下表：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-099f568819dbb05978634934e3aa585e_b.jpg alt></p><p>因此，为了避免出现平票的情况，副本集的部署一般采用是基数个节点，比如 3 个，正所谓三人行必有我师..</p><p><strong>心跳</strong></p><p>在高可用的实现机制中，心跳 (heartbeat) 是非常关键的，判断一个节点是否宕机就取决于这个节点的心跳是否还是正常的。<br>副本集中的每个节点上都会定时向其他节点发送心跳，以此来感知其他节点的变化，比如是否失效、或者角色发生了变化。<br>利用心跳，MongoDB 副本集实现了自动故障转移的功能，如下图：</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-81382e5544264faae3d6954584fe9254_r.jpg alt></p><p>默认情况下，节点会每 2 秒向其他节点发出心跳，这其中包括了主节点。 如果备节点在 10 秒内没有收到主节点的响应就会主动发起选举。<br>此时新一轮选举开始，新的主节点会产生并接管原来主节点的业务。 整个过程对于上层是透明的，应用并不需要感知，因为 Mongos 会自动发现这些变化。<br>如果应用仅仅使用了单个副本集，那么就会由 Driver 层来自动完成处理。</p><p><strong>复制</strong></p><p>主节点和备节点的数据是通过日志 (oplog) 复制来实现的，这很类似于 mysql 的 binlog。<br>在每一个副本集的节点中，都会存在一个名为 local.oplog.rs 的特殊集合。 当 Primary 上的写操作完成后，会向该集合中写入一条 oplog，<br>而 Secondary 则持续从 Primary 拉取新的 oplog 并在本地进行回放以达到同步的目的。</p><p>下面，看看一条 oplog 的具体形式：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>&#34;ts&#34;</span> : <span>Timestamp(</span><span style=color:#666>1446011584</span>, <span>2),</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>&#34;h&#34;</span> : <span>NumberLong(</span><span style=color:#b44>&#34;1687359108795812092&#34;</span><span>)</span>,
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>&#34;v&#34;</span> : <span style=color:#666>2</span>,
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>&#34;op&#34;</span> : <span style=color:#b44>&#34;i&#34;</span>,
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>&#34;ns&#34;</span> : <span style=color:#b44>&#34;test.nosql&#34;</span>,
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>&#34;o&#34;</span> : { <span style=color:green;font-weight:700>&#34;_id&#34;</span> : <span>ObjectId(</span><span style=color:#b44>&#34;563062c0b085733f34ab4129&#34;</span><span>)</span>, <span style=color:green;font-weight:700>&#34;name&#34;</span> : <span style=color:#b44>&#34;mongodb&#34;</span>, <span style=color:green;font-weight:700>&#34;score&#34;</span> : <span style=color:#b44>&#34;100&#34;</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中的一些关键字段有：</p><ul><li>ts 操作的 optime，该字段不仅仅包含了操作的时间戳 (timestamp)，还包含一个自增的计数器值。</li><li>h 操作的全局唯一表示</li><li>v oplog 的版本信息</li><li>op 操作类型，比如 i=insert,u=update..</li><li>ns 操作集合，形式为 database.collection</li><li>o 指具体的操作内容，对于一个 insert 操作，则包含了整个文档的内容</li></ul><p>MongoDB 对于 oplog 的设计是比较仔细的，比如：</p><ul><li>oplog 必须保证有序，通过 optime 来保证。</li><li>oplog 必须包含能够进行数据回放的完整信息。</li><li>oplog 必须是幂等的，即多次回放同一条日志产生的结果相同。</li><li>oplog 集合是固定大小的，为了避免对空间占用太大，旧的 oplog 记录会被滚动式的清理。</li></ul><p>有兴趣的读者，可以参考官方文档：</p><p><a href="https://link.zhihu.com/?target=https%3A//docs.mongodb.com/manual/core/replica-set-oplog/index.html" target=_blank rel=noopener>https://docs.mongodb.com/manual/core/replica-set-oplog/index.html</a></p><h2 id=六事务与一致性><strong>六、事务与一致性</strong></h2><p>一直以来，&ldquo;不支持事务&rdquo; 是 MongoDB 一直被诟病的问题，当然也可以说这是 NoSQL 数据库的一种权衡 (放弃事务，追求高性能、高可扩展)<br>但实质上，MongoDB 很早就有事务的概念，但是这个事务只能是针对单文档的，即单个文档的操作是有原子性保证的。<br>在 4.0 版本之后，MongoDB 开始支持多文档的事务：</p><ul><li>4.0 版本支持副本集范围的多文档事务。</li><li>4.2 版本支持跨分片的多文档事务 (基于两阶段提交)。</li></ul><p>在事务的隔离性上，MongoDB 支持快照 (snapshot) 的隔离级别，可以避免脏读、不可重复读和幻读。<br>尽管有了真正意义上的事务功能，但多文档事务对于性能有一定的影响，应用应该在充分评估后再做选用。</p><h3 id=一致性><strong>一致性</strong></h3><p>一致性是一个复杂的话题，而一致性更多从应用角度上提出的，比如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>向系统写入一条数据，应该能够马上读到写入的这个数据。
</span></span></code></pre></div><p>在分布式架构的 CAP 理论以及许多延续的观点中提到，由于网络分区的存在，要求系统在一致性和可用性之间做出选择，而不能两者兼得。</p><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/v2-12e5c64d1e1df25b325af95055a7012c_r.jpg alt></p><p>图 -CAP 理论</p><p>在 MongoDB 中，这个选择是可以由开发者来定的。 MongoDB 允许客户端为其操作设定一定的级别或者偏好，包括：</p><ul><li>read preference<br>读取偏好，可指定读主节点、读备节点，或者是优先读主、优先读备、取最近的节点</li><li>write concern<br>写关注，指定写入结果达到什么状态时才返回，可以为无应答 (none)、应答 (ack)，或者是大多数节点完成了数据复制等等</li><li>read concern<br>读关注，指定读取的数据版本处于怎样的状态，可以为读本地、读大多数节点写入，或者是线性读 (linearizable) 等等。</li></ul><p>使用不同的设定将会产生对于 C(一致性)、A(可用性) 的不同的抉择，比如：</p><ul><li>将读偏好设置为 primary，此时读写都在主节点上。 这保证了数据的一致性，但一旦主节点宕机会导致失败 (可用性降低)</li><li>将读偏好设置为 secondaryPrefered，此时写主，优先读备，可用性提高了，但数据存在延迟 (出现不一致)</li><li>将读写关注都设置为 majority(大多数)，一致性提升了，但可用性也同时降低了 (节点失效会导致大多数写失败)</li></ul><p>关于这种权衡的讨论会一直存在，而 MongoDB 除了提供多样化的选择之外，其主要是通过复制、基于心跳的自动 failover 等机制来降低系统发生故障时产生的影响，从而提升整体的可用性。</p><h2 id=小结><strong>小结</strong></h2><p>本文主要揭示了 MongoDB 多个方面的细节，同时在使用体验上也借助 SQL 的概念做了一些对比。<br>从笔者的角度看，MongoDB 的发展性是很强的，其灵活快速的开发模式、天生自带分布式等能力弥补了传统型 SQL 数据库的缺陷。当然，目前的 NewSQL 本质上也貌似在以 &ldquo;模仿的方式&rdquo; 弥补这些缺陷。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/mongodb rel=tag title=MongoDB>#MongoDB#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>QQ扫一扫交流</div></div><div class=article-copyright-info><p><span>标题：</span>MongoDB学习总结</p><p><span>链接：</span>https://codingroam.github.io/post/mongodb-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</p><p><span>作者：</span>roam</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=https://codingroam.github.io/post/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1%E4%B8%80/ rel=next title=Redis场景设计(一)><i class="fa fa-chevron-left"></i> Redis场景设计(一)</a></div><div class="post-nav-prev post-nav-item"><a href=https://codingroam.github.io/post/15%E4%B8%AA%E5%BF%85%E7%9F%A5%E7%9A%84-mysql-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/ rel=prev title="15个必知的 Mysql 索引失效场景">15个必知的 Mysql 索引失效场景
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.png alt=roam><p class=site-author-name itemprop=name>roam</p><p class="site-description motion-element" itemprop=description>以为打得赢我啊你</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>80</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>27</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>56</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/wk123456/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://www.zhihu.com/ target=_blank title=知乎><i class="fa fa-fw fa-globe"></i>
知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class=links-of-blogroll-title><i class="fa fa-fw fa-globe"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://nutzam.com/ title=Nutz target=_blank>Nutz</a></li><li class=links-of-blogroll-item><a href=https://jfinal.com/ title=JFinal target=_blank>JFinal</a></li><li class=links-of-blogroll-item><a href=http://wendal.net/ title=Wendal target=_blank>Wendal</a></li><li class=links-of-blogroll-item><a href=https://www.liaoxuefeng.com/ title=廖雪峰 target=_blank>廖雪峰</a></li></ul></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/learning>Learning
<sup>27</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/mysql>Mysql
<sup>12</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/java>Java
<sup>11</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6>中间件
<sup>10</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/golang>Golang
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/golang%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0>Golang编程学习
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/linux>Linux
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/redis>Redis
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/problem-solving>Problem solving
<sup>7</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/docker>Docker
<sup>6</sup></a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2024</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>想学啊你</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.115.4</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=https://gitee.com/ style=font-weight:700 target=_blank>Gitee 仓库</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href=http://beian.miit.gov.cn target=_blank>粤 ICP 备 18047355 号</a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//unpkg.com/jquery@2.1.4/dist/jquery.min.js></script>
<script type=text/javascript src=https://codingroam.github.io/js/search.js></script>
<script type=text/javascript src=https://codingroam.github.io/js/affix.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".footer").outerHeight(!0),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var e,t,n,s,o=$(".header-inner").height()+10;$("#sidebar").css({"margin-top":o}).show(),t=parseInt($("#sidebar").css("margin-top")),n=parseInt($(".sidebar-inner").css("height")),e=t+n,s=$(".content-wrap").height(),s<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script type=text/javascript>const locale={placeholder:"欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^"};$(function(){detectIE()>0?$.getScript(document.location.protocol+"//unpkg.com/@waline/client@1.6.0/dist/Waline.min.js",function(){new Waline({el:"#wcomments",visitor:!0,emoji:[],wordLimit:"200",uploadImage:!1,locale,requiredMeta:["nick","mail"],serverURL:"Your WalineSerURL",lang:"zh-cn"})}):$("#wcomments").html("抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。")})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script>
<script>(function(){var t,e=document.createElement("script"),n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>