<!doctype html><html lang=zh-cn dir=content/zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>MySql原理学习记录 - 好记性不如烂笔头</title><meta name=keywords content="博客,程序员,架构师,思考,读书,笔记,技术,分享,大数据,产品"><meta name=author content="极光code"><meta property="og:title" content="MySql原理学习记录"><meta property="og:site_name" content="好记性不如烂笔头"><meta property="og:image" content="/img/author.jpg"><meta name=title content="MySql原理学习记录 - 好记性不如烂笔头"><meta name=description content="MySql learning"><link rel="shortcut icon" href=/img/favicon.ico><link rel=apple-touch-icon href=/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=/img/apple-touch-icon.png><link href=//unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>好记性不如烂笔头</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>锲而不舍，金石可镂！</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-active"><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/about.html rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于我</a></li><li class=menu-item><a href=/404.html rel=section><i class="menu-item-icon fa fa-fw fa-heartbeat"></i><br>公益404</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=/post/mysql%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/ itemprop=url>MySql原理学习记录</a></h1><div class=post-meta><span class=post-pushdate><i class="fa fa-calendar-o fa-fw"></i>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2022-06-02">2022-06-02</time></span>
<span class=post-category><i class="fa fa-folder-o fa-fw"></i>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/mysql itemprop=url rel=index><span itemprop=name>MySql</span></a>
&nbsp;</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/mysql-basis itemprop=url rel=index><span itemprop=name>MySql Basis</span></a>
&nbsp;</span></span>
<span class=post-wordcount><i class="fa fa-file-word-o fa-fw"></i>
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>6862 字</span></span>
<span class=post-readtime><i class="fa fa-eye fa-fw"></i>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>14分钟</span></span>
<span id=/post/mysql%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/ class="leancloud_visitors post-visitor" data-flag-title=MySql原理学习记录><i class="fa fa-binoculars fa-fw"></i>
<span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>根据《MySql是怎样运行的一书》整理记录知识点</p><h3 id=1-mysql编码>1 mysql编码</h3><ol><li><p><strong>mysql支持41种字符集包括常用的utf-8、ASCII、GB2312等</strong></p><ul><li>utf是unicode编码的一种实现方式，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符</li><li>mysql中的utf8(utf8mb3)是标准utf8的阉割版，采用1~3个字节存储字符，涵盖常用字符的表示范围</li><li>mysql中utf8mb4 才是正宗的 utf8 字符集，使用1～4个字节表示字符，可以表示不常用字符，如表情符号等</li><li>SHOW CHARACTER SET;查看字符集</li></ul></li><li><p><strong>比较规则，比较规则和字符集是绑定的</strong></p><p>每种字符集都有几种对应的比较规则，如忽略大小写等，比较规则用于比较字符或者排序（order by）</p><ul><li>SHOW COLLATION [LIKE 匹配的模式];</li><li>SHOW COLLATION LIKE &lsquo;utf8_%&rsquo;;查看utf8编码的比较规则</li></ul></li><li><p><strong>字符集和比较规则的应用</strong></p><ul><li><p>MySQL 有4个级别的字符集和比较规则，数据字符集采用就近原则，如果没有就从上级继承，从上到下级别分别是：①服务器级别②数据库③表级别④列级别</p></li><li><p>以服务器级别为例：</p><p>SHOW VARIABLES in(&lsquo;character_set_server&rsquo;,&lsquo;collation_server&rsquo;);查看服务器级别的字符集和比较规则</p></li></ul></li><li><p><strong>数据库乱码原因及原理</strong></p><ul><li><p><b>结论</b>：<strong>编码和解码使用的字符集不一致的后果</strong></p><p>mysql字符编系统变量</p><p><img src=/images/mysqlcodec.png alt=fileinfo></p></li><li><p>过程：客户端发往服务器的请求本质上就是一个字符串，服务器向客户端返回的结果本质上也是一个字符。过程分为三步：①客户端发送往服务器的字符串经过编码成二进制数据才能发送，比如客户端的默认编码是gbk，发送的数据就是以gbk字符集编码的二进制数据，数据到了mysql端，mysql就会使用character_set_client字符集来对数据进行解码，如果字符集不是gbk这一步就会乱码，导致sql语句无法正确解析②第一步成功编解码之后，服务器会把字符按照character_set_connection字符集进行编码，然后拿着编码后的数据去数据库表中对应列进行匹配（数据库中字段值是按照character_set_connection字符集编码后存储的）③最后将查出来的数据用character_set_results编码之后发给客户端，客户端再用客户端默认字符集解码得到最终展示数据</p></li><li><p><strong>总结</strong>：服务器认为客户端发送过来的请求是用 character_set_client 编码的。假设你的客户端采用的字符集和 <strong>character_set_client</strong> 不一样的话，这就会出现意想不到的情况。比如我的客户端使用的是 utf8 字符集，如果把系统变量 character_set_client 的值设置为 ascii 的话，服务器可能无法理解我们发送的请求，更别谈处理这个请求了。服务器将把得到的结果集使用 character_set_results 编码后发送给客户端。假设你的客户端采用的字符集和 <strong>character_set_results</strong> 不一样的话，这就可能会出现客户端无法解码结果集的情况，结果就是在你的屏幕上出现乱码。<strong>客户端默认字符集==character_set_client==character_set_results</strong>才不会乱码</p></li><li><p>设置成统一字符集</p><p>SET NAMES 字符集名;</p><p>等价于：</p><p>SET character_set_client = 字符集名;</p><p>SET character_set_connection = 字符集名;</p><p>SET character_set_results = 字符集名;</p><p>等价于：</p><p>在my.cnf配置文件中</p><p>[client]</p><p>default-character-set=字符集名</p></li></ul></li></ol><h3 id=2-存储引擎innodb>2 存储引擎InnoDB</h3><ul><li><p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 行格式 或者 记录格式
设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 Compact 、 Redundant
Dynamic 和 Compressed 行格式</p></li><li><p>行格式用法：</p><p>CREATE TABLE 表名 (列的信息) ROW_FORMAT=Compact</p><p>ALTER TABLE 表名 ROW_FORMAT=Compact</p></li><li><p>compact行格式</p><p><img src=/images/mysqlcompact.png alt=fileinfo></p></li><li><p>变长字段长度列表</p><p>变长字段，使用变长数据类型（varchar(n)，blob,text等）或者变长字符集（如utf8是1~3个字符）存储的字段。在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，</p></li><li><p><strong>NULL</strong>值列表</p><p>我们知道表中的某些列可能存储 NULL 值，如果把这些 NULL 值都放到 记录的真实数据 中存储会很占地方，所以 Compact 行格式把这些值为 NULL 的列统一管理起来，存储到 NULL 值列表中，它的处理过程是这样的：</p><ol><li><p>首先统计表中允许存储 NULL 的列有哪些。我们前边说过，主键列、被 NOT NULL 修饰的列都是不可以存储 NULL 值的，所以在统计的时候不会把这些列算进去。比方说表 record_format_demo 的3个列 c1 、 c3 、 c4 都是允许存储 NULL 值的，而 c2 列是被NOT NULL 修饰，不允许存储 NULL 值。</p></li><li><p>如果表中没有允许存储 <strong>NULL</strong> 的列，则 <em>NULL</em>值列表 也不存在了，否则将每个允许存储 NULL 的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：二进制位的值为 1 时，代表该列的值为 NULL 。二进制位的值为 0 时，代表该列的值不为 NULL</p></li><li><p>MySQL 规定 NULL值列表 必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补 0 。 表 record_format_demo 只有3个值允许为 NULL 的列，对应3个二进制位，不足一个字节，所以在字节的高位补 0</p></li></ol></li><li><p>记录头信息</p><p>除了 变长字段长度列表 、 NULL值列表 之外，还有一个用于描述记录的 记录头信息 ，它是由固定的 5 个字节组成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思</p></li><li><p>存储行</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>/*MySQL 对一条记录占用的最大存储空间是有限制的，除了 BLOB 或者 TEXT 类型的列之
</span></span><span style=display:flex><span>外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节
</span></span><span style=display:flex><span>存储一个 VARCHAR(M) 类型的列，其实需要占用3部分存储空间：
</span></span><span style=display:flex><span>①真实数据
</span></span><span style=display:flex><span>②真实数据占用字节的长度
</span></span><span style=display:flex><span>③NULL 值标识，如果该列有 NOT NULL 属性则可以没有这部分存储空间
</span></span><span style=display:flex><span>如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据，因为真实数据的长度可能
</span></span><span style=display:flex><span>占用2个字节， NULL 值标识需要占用1个字节：
</span></span><span style=display:flex><span>*/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>CREATE TABLE varchar_size_demo(
</span></span><span style=display:flex><span>c1 VARCHAR(65532)
</span></span><span style=display:flex><span>)CHARSET=ASCII ROW_FORMAT=COMPACT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>/*编码如果是gbk,最多只能32766 （也就是：65532/2），因为gbk一个字符占两个字节
</span></span><span style=display:flex><span>utf8 字符集表示一个字符最多需要 3 个字节，那在该字符集下， M 的最大取值就是 21844 ，就是说最多能存
</span></span><span style=display:flex><span>储 21844 （也就是：65532/3）个字符*/
</span></span><span style=display:flex><span>/*这些都是表中只有一个字段的情况下，如果是多个字段，则所有字段（（不包括隐藏
</span></span><span style=display:flex><span>列和记录头信息））加起来不能超过65535*/
</span></span><span style=display:flex><span>CREATE TABLE varchar_size_demo(
</span></span><span style=display:flex><span>c VARCHAR(32766)
</span></span><span style=display:flex><span>) CHARSET=gbk ROW_FORMAT=COMPACT;
</span></span></code></pre></div></li></ul><h3 id=3-访问方法>3 访问方法</h3><ol><li><p><strong>const</strong>: 通过<strong>主键</strong>或者<strong>唯一二级索引列</strong>与常数的<strong>等值比较</strong>来定位一条记录,如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较</p></li><li><p><strong>ref</strong>：通过某个普通的二级索引列与常数进行等值比较（普通二级索引与唯一二级索引对应，普通二级索引等值比较可能查出多个列）</p><ul><li><p>二级索引列值为 NULL 的情况</p><p>不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含 NULL 值的数量并不限制，所以我们采用key IS NULL 这种形式的搜索条件最多只能使用 ref 的访问方法，而不是 const 的访问方法。</p></li><li><p>对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用 ref的访问方法，比方说下边这几个查询：</p><p>SELECT * FROM single_table WHERE key_part1 = &lsquo;god like&rsquo;;</p><p>SELECT * FROM single_table WHERE key_part1 = &lsquo;god like&rsquo; AND key_part2 = &rsquo;legendary&rsquo;;</p><p>SELECT * FROM single_table WHERE key_part1 = &lsquo;god like&rsquo; AND key_part2 = &rsquo;legendary&rsquo;</p><p>AND key_part3 = &lsquo;penta kill&rsquo;。但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为 ref 了，比方说这样： SELECT * FROM single_table WHERE key_part1 = &lsquo;god like&rsquo; AND key_part2 > &rsquo;legendary&rsquo;;</p></li></ul></li><li><p><strong>ref_or_null</strong>：有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为 NULL 的记录也找出来，就像下边这个查询：</p></li></ol><p>SELECT * FROM single_demo WHERE key1 = &lsquo;abc&rsquo; OR key1 IS NULL;</p><ol start=4><li><p><strong>range</strong>：利用索引进行范围匹配</p></li><li><p><strong>index</strong>：遍历二级索引记录的执行方式</p><p>SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = &lsquo;abc&rsquo;;</p><p>key_part1, key_part2, key_part3三个要查询的字段是联合索引，查询条件key_part2 不是最左索引，此时需要直接通过遍历 idx_key_part 索引的叶子节点的记录来比较 key_part2 = &lsquo;abc&rsquo; 这个条件是否成立，把匹配成功的二级索引记录的 key_part1 , key_part2 , key_part3 列的值直接加到结果集中就行了，不需要回表</p><p>当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index ，比如这样：</p><p>mysql> EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &lsquo;a&rsquo;;</p><p>+&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;-</p><p>&mdash;&ndash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p><p>| id | select_type | table | partitions | type | possible_keys | key | key</p><p>_len | ref | rows | filtered | Extra |</p><p>+&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;-</p><p>&mdash;&ndash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p><p>| 1 | SIMPLE | s1 | NULL | index | NULL | idx_key_part | 909</p><p>| NULL | 9688 | 10.00 | Using where; Using index |</p><p>+&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;-</p><p>&mdash;&ndash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+</p><p>1 row in set, 1 warning (0.00 sec)</p><p>上述查询中的搜索列表中只有 key_part2 一个列，而且搜索条件中也只有 key_part3 一个列，这两个列又恰</p><p>好包含在 idx_key_part 这个索引中，可是搜索条件 key_part3 不能直接使用该索引进行 ref 或者 range 方</p><p>式的访问，只能扫描整个 idx_key_part 索引的记录，所以查询计划的 type 列的值就是 index 。</p><p>小贴士：</p><p>再一次强调，对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，</p><p>而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，</p><p>也就是扫描聚簇索引的代价更低一些。</p></li><li><p><strong>all</strong>：全表扫描</p></li><li><p><strong>eq_ref</strong>：在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是</p><p>eq_ref</p></li><li><p><strong>index_merge</strong>：一般情况下对于某个表的查询只能使用到一个索引，在某些场景下可以使用 Intersection 、 Union 、 Sort-Union 这三种索引合并的方式来执行查询，如</p><p>mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = &lsquo;a&rsquo; OR key3 = &lsquo;a&rsquo;;</p><p>+&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;</p><p>&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p><p>&mdash;&ndash;+</p><p>| id | select_type | table | partitions | type | possible_keys | key</p><p>| key_len | ref | rows | filtered | Extra |</p><p>+&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;</p><p>&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p><p>&mdash;&ndash;+</p><p>| 1 | SIMPLE | s1 | NULL | index_merge | idx_key1,idx_key3 | idx_key</p><p>1,idx_key3 | 303,303 | NULL | 14 | 100.00 | Using union(idx_key1,idx_key3); Using</p><p>where |</p><p>+&mdash;-+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;</p><p>&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-</p><p>&mdash;&ndash;+</p><p>1 row in set, 1 warning (0.01 sec)</p></li><li><p><strong>unique_subquery</strong>：类似于两表连接中被驱动表的 eq_ref 访问方法， unique_subquery 是针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 unique_subquery ，比如下边的这个查询语句：</p><p>mysql> EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.</p><p>key1) OR key3 = &lsquo;a&rsquo;;</p><p>+&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p><p>+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+</p><p>| id | select_type | table | partitions | type | possible_keys</p><p>| key | key_len | ref | rows | filtered | Extra |</p><p>+&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p><p>+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+</p><p>| 1 | PRIMARY | s1 | NULL | ALL | idx_key3</p><p>| NULL | NULL | NULL | 9688 | 100.00 | Using where |</p><p>| 2 | DEPENDENT SUBQUERY | s2 | NULL | unique_subquery | PRIMARY,idx_key1</p><p>| PRIMARY | 4 | func | 1 | 10.00 | Using where |</p><p>+&mdash;-+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p><p>+&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;+&mdash;&mdash;&mdash;-+&mdash;&mdash;&mdash;&mdash;-+</p></li><li><p><strong>system</strong>：当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是 system</p></li></ol><h3 id=4-redo-log>4 redo log</h3><ol><li><p><strong>概念</strong>：在系统奔溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为 重做日</p><p>志 ，英文名为 redo log 。</p></li><li><p>描述：想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好，这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来。</p></li><li><p>结构：</p><p>type ：该条 redo 日志的类型。</p><p>在 MySQL 5.7.21 这个版本中，设计 InnoDB 的大叔一共为 redo 日志设计了53种不同的类型，稍后会详细介</p><p>绍不同类型的 redo 日志。</p><p>space ID ：表空间ID。</p><p>page number ：页号。</p><p>data ：该条 redo 日志的具体内容。</p></li><li><p><strong>lsn和flushed_to_disk_lsn</strong>：日志序列号 ，简称 lsn有新的 redo 日志写入到 log buffer 时，首先 lsn 的值会增长。刷新到磁盘中的 redo 日志量的全局变量，称之为flushed_to_disk_lsn 。系统第一次启动时，该变量的值和初始的 lsn 值是相同的，都是 8704 。随着系统的运行， redo 日志被不断写入 log buffer ，但是并不会立即刷新到磁盘， lsn 的值就和 flushed_to_disk_lsn 的值拉开了差距，如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了</p></li><li><p><strong>checkpoint</strong>：全局变量 checkpoint_lsn 来代表当前系统中可以被覆盖的 redo 日志总量是多少，比方说现在 页a 被刷新到了磁盘， mtr_1 生成的 redo 日志就可以被覆盖了，所以我们可以进行一个增加checkpoint_lsn 的操作，我们把这个过程称之为做一次 checkpoint 。计算一下当前系统中可以被覆盖的 redo 日志对应的 lsn 值最大是多少，redo 日志可以被覆盖，意味着它对应的脏页被刷到了磁盘，只要我们计算出当前系统中被最早修改的脏页对应的 oldest_modification 值，那凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的，我们就把该脏页的 oldest_modification 赋值给 checkpoint_lsn</p></li></ol><h3 id=5-undo-log>5 undo log</h3><ol><li>定义：在事务中为了回滚而记录的这些东东称之为撤销日志，英文名为 undo log</li></ol><h3 id=6-隔离级别>6 隔离级别</h3><ol><li><p>事务并发遇到的问题：</p><ul><li>脏写（ Dirty Write ）：如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了 脏写</li><li>脏读（ Dirty Read ）：如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了 脏读</li><li>不可重复读（Non-Repeatable Read）：如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了 不可重复读</li><li>幻读（Phantom）：如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了 幻读</li></ul></li><li><p>四种隔离级别：</p><p>READ UNCOMMITTED ：未提交读。</p><p>READ COMMITTED ：已提交读。</p><p>REPEATABLE READ ：可重复读。</p><p>SERIALIZABLE ：可串行化。</p><p>READ UNCOMMITTED 隔离级别下，可能发生 脏读 、 不可重复读 和 幻读 问题。</p><p>READ COMMITTED 隔离级别下，可能发生 不可重复读 和 幻读 问题，但是不可以发生 脏读 问题。</p><p>REPEATABLE READ 隔离级别下，可能发生 幻读 问题，但是不可以发生 脏读 和 不可重复读 的问题。</p><p>SERIALIZABLE 隔离级别下，各种问题都不可以发生。</p><p><strong>MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的</strong></p></li><li><p><strong>MVCC原理</strong></p><ul><li><p>版本链描述：每次对记录进行改动，都会记录一条 undo日志 ，每条 undo日志 也都有一个 roll_pointer 属性（ INSERT 操作对应的 undo日志 没有该属性，因为该记录并没有更早的版本），可以将这些 undo日志 都连来，串成一个链表，对该记录每次更新后，都会将旧值放到一条 undo日志 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为 版本链 ，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的 事务id</p></li><li><p><strong>ReadView</strong>：对于使用 READ UNCOMMITTED 隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；对于使用 SERIALIZABLE 隔离级别的事务来说，设计 InnoDB 的大叔规定使用加锁的方式来访问记录（加锁是啥我们后续文章中说哈）；对于使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。为此，设计 InnoDB 的大叔提出了一个 ReadView 的概念，这个 ReadView 中主要包含4个比较重要的内容：</p><p>m_ids ：表示在生成 ReadView 时当前系统中活跃的读写事务的 事务id 列表。</p><p>min_trx_id ：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的 事务id ，也就是 m_ids 中的最</p><p>小值。</p><p>max_trx_id ：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值。</p><p>小贴士：</p><p>注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三</p><p>个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，mi</p><p>n_trx_id的值就是1，max_trx_id的值就是4。</p><p>creator_trx_id ：表示生成该 ReadView 的事务的 事务id 。</p><p>有了这个 ReadView ，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><p>如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己</p><p>修改过的记录，所以该版本可以被当前事务访问。如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</p><p>如果被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。</p><p>如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下</p><p>trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该</p><p>版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</p><p>**在 MySQL 中， READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同，<strong>READ COMMITTED ——</strong> <strong>每次读取数据前都生成一个****ReadView</strong>，<strong>REPEATABLE READ ——</strong> <strong>在第一次读取数据时生成一个****ReadView</strong></p><p><strong>小结：从上边的描述中我们可以看出来，所谓的 MVCC （Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 READ COMMITTD 、 REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。 READ COMMITTD 、REPEATABLE READ 这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。</strong></p></li></ul></li></ol></div><footer class=post-footer><div class=post-tags><a href=/tags/mysql rel=tag title=MySql>#MySql#</a>
<a href=/tags/%e5%8e%9f%e7%90%86%e7%9f%a5%e8%af%86 rel=tag title=原理知识>#原理知识#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>QQ扫一扫交流</div></div><div class=article-copyright-info><p><span>标题：</span>MySql原理学习记录</p><p><span>链接：</span>/post/mysql%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</p><p><span>作者：</span>极光code</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ rel=next title=java设计模式><i class="fa fa-chevron-left"></i> java设计模式</a></div><div class="post-nav-prev post-nav-item"><a href=/post/vmware%E8%99%9A%E6%8B%9F%E6%9C%BAcentos-7.5%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81ip/ rel=prev title="VMware虚拟机CentOS 7.5设置静态ip">VMware虚拟机CentOS 7.5设置静态ip
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.png alt=极光code><p class=site-author-name itemprop=name>极光code</p><p class="site-description motion-element" itemprop=description>以梦为马，不负韶华!</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>11</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>9</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>19</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/wk123456/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://www.zhihu.com/ target=_blank title=知乎><i class="fa fa-fw fa-globe"></i>
知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class=links-of-blogroll-title><i class="fa fa-fw fa-globe"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://nutzam.com/ title=Nutz target=_blank>Nutz</a></li><li class=links-of-blogroll-item><a href=https://jfinal.com/ title=JFinal target=_blank>JFinal</a></li><li class=links-of-blogroll-item><a href=http://wendal.net/ title=Wendal target=_blank>Wendal</a></li><li class=links-of-blogroll-item><a href=https://www.liaoxuefeng.com/ title=廖雪峰 target=_blank>廖雪峰</a></li></ul></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/linux>Linux
<sup>5</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/command>Command
<sup>2</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/markdown>Markdown
<sup>2</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/mysql>Mysql
<sup>2</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/centos-7>Centos 7
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/css>Css
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/design-pattern>Design pattern
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/html>HTML
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/ip>IP
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/java>Java
<sup>1</sup></a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2022</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>好记性不如烂笔头</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.99.1</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=https://gitee.com/ style=font-weight:700 target=_blank>Gitee 仓库</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href=http://beian.miit.gov.cn target=_blank>粤 ICP 备 18047355 号</a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//unpkg.com/jquery@2.1.4/dist/jquery.min.js></script>
<script type=text/javascript src=/js/search.js></script>
<script type=text/javascript src=/js/affix.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".footer").outerHeight(!0),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var e,t,n,s,o=$(".header-inner").height()+10;$("#sidebar").css({'margin-top':o}).show(),t=parseInt($("#sidebar").css("margin-top")),n=parseInt($(".sidebar-inner").css("height")),e=t+n,s=$(".content-wrap").height(),s<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script type=text/javascript>const locale={placeholder:"欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^"};$(function(){detectIE()>0?$.getScript(document.location.protocol+"//unpkg.com/@waline/client@1.6.0/dist/Waline.min.js",function(){new Waline({el:"#wcomments",visitor:!0,emoji:[],wordLimit:"200",uploadImage:!1,locale,requiredMeta:["nick","mail"],serverURL:"Your WalineSerURL",lang:"zh-cn"})}):$("#wcomments").html("抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。")})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script>
<script>(function(){var t,e=document.createElement("script"),n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>