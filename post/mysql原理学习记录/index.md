# MySql原理学习记录


根据《MySql是怎样运行的一书》整理记录知识点

<!--more-->

### 1 mysql编码

1. **mysql支持41种字符集包括常用的utf-8、ASCII、GB2312等**
   + utf是unicode编码的一种实现方式，utf8使用1～4个字节编码一个字符，utf16使用2个或4个字节编码一个字符，utf32使用4个字节编码一个字符
   + mysql中的utf8(utf8mb3)是标准utf8的阉割版，采用1~3个字节存储字符，涵盖常用字符的表示范围
   + mysql中utf8mb4 才是正宗的 utf8 字符集，使用1～4个字节表示字符，可以表示不常用字符，如表情符号等
   + SHOW CHARACTER SET;查看字符集

2. **比较规则，比较规则和字符集是绑定的**

   每种字符集都有几种对应的比较规则，如忽略大小写等，比较规则用于比较字符或者排序（order by）

   + SHOW COLLATION [LIKE 匹配的模式];
   + SHOW COLLATION LIKE 'utf8\_%';查看utf8编码的比较规则



3. **字符集和比较规则的应用**

   + MySQL 有4个级别的字符集和比较规则，数据字符集采用就近原则，如果没有就从上级继承，从上到下级别分别是：①服务器级别②数据库③表级别④列级别

   + 以服务器级别为例：

     SHOW VARIABLES in('character_set_server','collation_server');查看服务器级别的字符集和比较规则

     

     

4. **数据库乱码原因及原理**

   + <b>结论</b>：**编码和解码使用的字符集不一致的后果**

     mysql字符编系统变量

     ![fileinfo](/images/mysqlcodec.png)

   

   + 过程：客户端发往服务器的请求本质上就是一个字符串，服务器向客户端返回的结果本质上也是一个字符。过程分为三步：①客户端发送往服务器的字符串经过编码成二进制数据才能发送，比如客户端的默认编码是gbk，发送的数据就是以gbk字符集编码的二进制数据，数据到了mysql端，mysql就会使用character_set_client字符集来对数据进行解码，如果字符集不是gbk这一步就会乱码，导致sql语句无法正确解析②第一步成功编解码之后，服务器会把字符按照character_set_connection字符集进行编码，然后拿着编码后的数据去数据库表中对应列进行匹配（数据库中字段值是按照character_set_connection字符集编码后存储的）③最后将查出来的数据用character_set_results编码之后发给客户端，客户端再用客户端默认字符集解码得到最终展示数据

   + **总结**：服务器认为客户端发送过来的请求是用 character_set_client 编码的。假设你的客户端采用的字符集和 **character_set_client** 不一样的话，这就会出现意想不到的情况。比如我的客户端使用的是 utf8 字符集，如果把系统变量 character_set_client 的值设置为 ascii 的话，服务器可能无法理解我们发送的请求，更别谈处理这个请求了。服务器将把得到的结果集使用 character_set_results 编码后发送给客户端。假设你的客户端采用的字符集和 **character_set_results** 不一样的话，这就可能会出现客户端无法解码结果集的情况，结果就是在你的屏幕上出现乱码。**客户端默认字符集==character_set_client==character_set_results**才不会乱码

   + 设置成统一字符集

     SET NAMES 字符集名;

     等价于：

     SET character_set_client = 字符集名;

     SET character_set_connection = 字符集名;

     SET character_set_results = 字符集名;

     等价于：

     在my.cnf配置文件中

     [client]

     default-character-set=字符集名

### 2 存储引擎InnoDB

+ 我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 行格式 或者 记录格式 
  设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 Compact 、 Redundant 
  Dynamic 和 Compressed 行格式

+ 行格式用法：

  CREATE TABLE 表名 (列的信息) ROW_FORMAT=Compact 

  ALTER TABLE 表名 ROW_FORMAT=Compact 

+ compact行格式

  ![fileinfo](/images/mysqlcompact.png)

+ 变长字段长度列表

  变长字段，使用变长数据类型（varchar(n)，blob,text等）或者变长字符集（如utf8是1~3个字符）存储的字段。在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，

+ **NULL**值列表

  我们知道表中的某些列可能存储 NULL 值，如果把这些 NULL 值都放到 记录的真实数据 中存储会很占地方，所以 Compact 行格式把这些值为 NULL 的列统一管理起来，存储到 NULL 值列表中，它的处理过程是这样的：

  1. 首先统计表中允许存储 NULL 的列有哪些。我们前边说过，主键列、被 NOT NULL 修饰的列都是不可以存储 NULL 值的，所以在统计的时候不会把这些列算进去。比方说表 record_format_demo 的3个列 c1 、 c3 、 c4 都是允许存储 NULL 值的，而 c2 列是被NOT NULL 修饰，不允许存储 NULL 值。

  2. 如果表中没有允许存储 **NULL** 的列，则 *NULL*值列表 也不存在了，否则将每个允许存储 NULL 的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：二进制位的值为 1 时，代表该列的值为 NULL 。二进制位的值为 0 时，代表该列的值不为 NULL 

  3.  MySQL 规定 NULL值列表 必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补 0 。 表 record_format_demo 只有3个值允许为 NULL 的列，对应3个二进制位，不足一个字节，所以在字节的高位补 0 

     

+ 记录头信息

  除了 变长字段长度列表 、 NULL值列表 之外，还有一个用于描述记录的 记录头信息 ，它是由固定的 5 个字节组成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思

+ 存储行

  ``` 
  /*MySQL 对一条记录占用的最大存储空间是有限制的，除了 BLOB 或者 TEXT 类型的列之
  外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节
  存储一个 VARCHAR(M) 类型的列，其实需要占用3部分存储空间：
  ①真实数据
  ②真实数据占用字节的长度
  ③NULL 值标识，如果该列有 NOT NULL 属性则可以没有这部分存储空间
  如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据，因为真实数据的长度可能
  占用2个字节， NULL 值标识需要占用1个字节：
  */
  
  CREATE TABLE varchar_size_demo(
  c1 VARCHAR(65532)
  )CHARSET=ASCII ROW_FORMAT=COMPACT;
  
  /*编码如果是gbk,最多只能32766 （也就是：65532/2），因为gbk一个字符占两个字节
  utf8 字符集表示一个字符最多需要 3 个字节，那在该字符集下， M 的最大取值就是 21844 ，就是说最多能存
  储 21844 （也就是：65532/3）个字符*/
  /*这些都是表中只有一个字段的情况下，如果是多个字段，则所有字段（（不包括隐藏
  列和记录头信息））加起来不能超过65535*/
  CREATE TABLE varchar_size_demo(
  c VARCHAR(32766)
  ) CHARSET=gbk ROW_FORMAT=COMPACT;
  ```


### 3 访问方法

1. **const**:  通过**主键**或者**唯一二级索引列**与常数的**等值比较**来定位一条记录,如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较

2. **ref**：通过某个普通的二级索引列与常数进行等值比较（普通二级索引与唯一二级索引对应，普通二级索引等值比较可能查出多个列）

   + 二级索引列值为 NULL 的情况

     不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含 NULL 值的数量并不限制，所以我们采用key IS NULL 这种形式的搜索条件最多只能使用 ref 的访问方法，而不是 const 的访问方法。

   + 对于某个包含多个索引列的二级索引来说，只要是最左边的连续索引列是与常数的等值比较就可能采用 ref的访问方法，比方说下边这几个查询：

      SELECT * FROM single_table WHERE key_part1 = 'god like';

      SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary';

      SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 = 'legendary'

     AND key_part3 = 'penta kill'。但是如果最左边的连续索引列并不全部是等值比较的话，它的访问方法就不能称为 ref 了，比方说这样： SELECT * FROM single_table WHERE key_part1 = 'god like' AND key_part2 > 'legendary';

3.  **ref_or_null**：有时候我们不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为 NULL 的记录也找出来，就像下边这个查询：

   SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;

4. **range**：利用索引进行范围匹配

5. **index**：遍历二级索引记录的执行方式

   SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';

    key_part1, key_part2, key_part3三个要查询的字段是联合索引，查询条件key_part2 不是最左索引，此时需要直接通过遍历 idx_key_part 索引的叶子节点的记录来比较 key_part2 = 'abc' 这个条件是否成立，把匹配成功的二级索引记录的 key_part1 , key_part2 , key_part3 列的值直接加到结果集中就行了，不需要回表

   当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是 index ，比如这样：

    mysql> EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = 'a';

    +----+-------------+-------+------------+-------+---------------+--------------+----

   -----+------+------+----------+--------------------------+

    | id | select_type | table | partitions | type | possible_keys | key | key

   _len | ref | rows | filtered | Extra |

    +----+-------------+-------+------------+-------+---------------+--------------+----

   -----+------+------+----------+--------------------------+

    | 1 | SIMPLE | s1 | NULL | index | NULL | idx_key_part | 909

   | NULL | 9688 | 10.00 | Using where; Using index |

    +----+-------------+-------+------------+-------+---------------+--------------+----

   -----+------+------+----------+--------------------------+

    1 row in set, 1 warning (0.00 sec)

   上述查询中的搜索列表中只有 key_part2 一个列，而且搜索条件中也只有 key_part3 一个列，这两个列又恰

   好包含在 idx_key_part 这个索引中，可是搜索条件 key_part3 不能直接使用该索引进行 ref 或者 range 方

   式的访问，只能扫描整个 idx_key_part 索引的记录，所以查询计划的 type 列的值就是 index 。

    小贴士：

    再一次强调，对于使用InnoDB存储引擎的表来说，二级索引的记录只包含索引列和主键列的值，

   而聚簇索引中包含用户定义的全部列以及一些隐藏列，所以扫描二级索引的代价比直接全表扫描，

   也就是扫描聚簇索引的代价更低一些。

6. **all**：全表扫描

7. **eq_ref**：在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是

   eq_ref 

8. **index_merge**：一般情况下对于某个表的查询只能使用到一个索引，在某些场景下可以使用 Intersection 、 Union 、 Sort-Union 这三种索引合并的方式来执行查询，如

    mysql> EXPLAIN SELECT * FROM s1 WHERE key1 = 'a' OR key3 = 'a';

    +----+-------------+-------+------------+-------------+-------------------+---------

   ----------+---------+------+------+----------+----------------------------------------

   -----+

    | id | select_type | table | partitions | type | possible_keys | key 

   | key_len | ref | rows | filtered | Extra |

    +----+-------------+-------+------------+-------------+-------------------+---------

   ----------+---------+------+------+----------+----------------------------------------

   -----+

    | 1 | SIMPLE | s1 | NULL | index_merge | idx_key1,idx_key3 | idx_key

   1,idx_key3 | 303,303 | NULL | 14 | 100.00 | Using union(idx_key1,idx_key3); Using

   where |

    +----+-------------+-------+------------+-------------+-------------------+---------

   ----------+---------+------+------+----------+----------------------------------------

   -----+

    1 row in set, 1 warning (0.01 sec)

9. **unique_subquery**：类似于两表连接中被驱动表的 eq_ref 访问方法， unique_subquery 是针对在一些包含 IN 子查询的查询语句中，如果查询优化器决定将 IN 子查询转换为 EXISTS 子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的 type 列的值就是 unique_subquery ，比如下边的这个查询语句：

    mysql> EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 = s2.

   key1) OR key3 = 'a';

    +----+--------------------+-------+------------+-----------------+------------------

   +---------+---------+------+------+----------+-------------+

    | id | select_type | table | partitions | type | possible_keys 

   | key | key_len | ref | rows | filtered | Extra |

    +----+--------------------+-------+------------+-----------------+------------------

   +---------+---------+------+------+----------+-------------+

    | 1 | PRIMARY | s1 | NULL | ALL | idx_key3 

   | NULL | NULL | NULL | 9688 | 100.00 | Using where |

    | 2 | DEPENDENT SUBQUERY | s2 | NULL | unique_subquery | PRIMARY,idx_key1

   | PRIMARY | 4 | func | 1 | 10.00 | Using where |

    +----+--------------------+-------+------------+-----------------+------------------

   +---------+---------+------+------+----------+-------------+

10. **system**：当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是 system



### 4 redo log

1. **概念**：在系统奔溃重启时需要按照上述内容所记录的步骤重新更新数据页，所以上述内容也被称之为 重做日志 ，英文名为 redo log 。

2. 描述：想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把修改了哪些东西记录一下就好，这样我们在事务提交时，把上述内容刷新到磁盘中，即使之后系统崩溃了，重启之后只要按照上述内容所记录的步骤重新更新一下数据页，那么该事务对数据库中所做的修改又可以被恢复出来。

3. 结构：

   type ：该条 redo 日志的类型。

   在 MySQL 5.7.21 这个版本中，设计 InnoDB 的大叔一共为 redo 日志设计了53种不同的类型，稍后会详细介

   绍不同类型的 redo 日志。

   space ID ：表空间ID。

   page number ：页号。

   data ：该条 redo 日志的具体内容。

4. 刷盘时机：redo日志不会直接写入磁盘，而是写入内存的log buffer中，将log buffer刷入磁盘的时机有以下几种情况：①log buffer空间不足②事务提交③后台线程大概每秒会做一次刷盘④正常关闭服务器时⑤做checkpoint时

5. **Mini-Transaction**：底层页面中的一次原子访问的过程称之为一个 Mini-Transaction ，简称 mtr ，比如上边

   所说的修改一次 Max Row ID 的值算是一个 Mini-Transaction ，向某个索引对应的 B+ 树中插入一条记录的过程也算是一个 Mini-Transaction 。通过上边的叙述我们也知道，一个所谓的 mtr 可以包含一组 redo 日志，在进行奔溃恢复时这一组 redo 日志作为一个不可分割的整体。一个事务可以包含若干条语句，每一条语句其实是由若干个 mtr 组成，每一个 mtr 又可以包含若干条 redo 日志

4.  **lsn和flushed_to_disk_lsn**：日志序列号 ，简称 lsn有新的 redo 日志写入到 log buffer 时，首先 lsn 的值会增长。刷新到磁盘中的 redo 日志量的全局变量，称之为flushed_to_disk_lsn 。系统第一次启动时，该变量的值和初始的 lsn 值是相同的，都是 8704 。随着系统的运行， redo 日志被不断写入 log buffer ，但是并不会立即刷新到磁盘， lsn 的值就和 flushed_to_disk_lsn 的值拉开了差距，如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了

7. **checkpoint**：全局变量 checkpoint_lsn 来代表当前系统中可以被覆盖的 redo 日志总量是多少，比方说现在 页a 被刷新到了磁盘， mtr_1 生成的 redo 日志就可以被覆盖了，所以我们可以进行一个增加checkpoint_lsn 的操作，我们把这个过程称之为做一次 checkpoint 。计算一下当前系统中可以被覆盖的 redo 日志对应的 lsn 值最大是多少，redo 日志可以被覆盖，意味着它对应的脏页被刷到了磁盘，只要我们计算出当前系统中被最早修改的脏页对应的 oldest_modification 值，那凡是在系统lsn值小于该节点的oldest_modification值时产生的redo日志都是可以被覆盖掉的，我们就把该脏页的 oldest_modification 赋值给 checkpoint_lsn

8. **崩溃恢复**：系统崩溃后重启时根据 redo 日志中的记录就可以将页面恢复到系统奔溃前的状态。

   1. **崩溃恢复起点**：checkpoint_lsn 之前的 redo 日志都可以被覆盖，也就是说这些 redo 日志对应的脏页都已经被刷新到磁盘中了，既然它们已经被刷盘，我们就没必要恢复它们了。对于 checkpoint_lsn 之后的 redo 日志，它们对应的脏页可能没被刷盘，也可能被刷盘了，我们不能确定，所以需要从 checkpoint_lsn 开始读取 redo 日志来恢复页面。
   2. **崩溃恢复的终点**：写 redo 日志的时候都是顺序写的，写满了一个block之后会再往下一个block，普通block的 log block header 部分有一个称之为 LOG_BLOCK_HDR_DATA_LEN 的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为 512 。如果该属性的值不为 512，那该block就是最后一个block，也就是redo日志的终点。
   3. **怎么恢复**：按照 redo 日志的顺序依次扫描checkpoint_lsn 之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来，

   

### 5 undo log

1. 定义：在事务中为了回滚而记录的这些东东称之为撤销日志，英文名为 undo log

### 6 隔离级别

1. 事务并发遇到的问题：
   + 脏写（ Dirty Write ）：如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了 脏写
   + 脏读（ Dirty Read ）：如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了 脏读
   + 不可重复读（Non-Repeatable Read）：如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了 不可重复读
   + 幻读（Phantom）：如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了 幻读

2. 四种隔离级别：

   READ UNCOMMITTED ：未提交读。

   READ COMMITTED ：已提交读。

   REPEATABLE READ ：可重复读。

   SERIALIZABLE ：可串行化。

   READ UNCOMMITTED 隔离级别下，可能发生 脏读 、 不可重复读 和 幻读 问题。

   READ COMMITTED 隔离级别下，可能发生 不可重复读 和 幻读 问题，但是不可以发生 脏读 问题。

   REPEATABLE READ 隔离级别下，可能发生 幻读 问题，但是不可以发生 脏读 和 不可重复读 的问题。

   SERIALIZABLE 隔离级别下，各种问题都不可以发生。

   **MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的**

3. **MVCC原理**

   + 版本链描述：每次对记录进行改动，都会记录一条 undo日志 ，每条 undo日志 也都有一个 roll_pointer 属性（ INSERT 操作对应的 undo日志 没有该属性，因为该记录并没有更早的版本），可以将这些 undo日志 都连来，串成一个链表，对该记录每次更新后，都会将旧值放到一条 undo日志 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为 版本链 ，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的 事务id

   + **ReadView**：对于使用 READ UNCOMMITTED 隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了；对于使用 SERIALIZABLE 隔离级别的事务来说，设计 InnoDB 的大叔规定使用加锁的方式来访问记录（加锁是啥我们后续文章中说哈）；对于使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。为此，设计 InnoDB 的大叔提出了一个 ReadView 的概念，这个 ReadView 中主要包含4个比较重要的内容：

     m_ids ：表示在生成 ReadView 时当前系统中活跃的读写事务的 事务id 列表。

     min_trx_id ：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的 事务id ，也就是 m_ids 中的最

     小值。

     max_trx_id ：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值。

      小贴士：

      注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三

     个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，mi

     n_trx_id的值就是1，max_trx_id的值就是4。

     creator_trx_id ：表示生成该 ReadView 的事务的 事务id 。

     

     有了这个 ReadView ，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

     如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己

     修改过的记录，所以该版本可以被当前事务访问。如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。

     如果被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。

     如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下

     trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该

     版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。

     **在 MySQL 中， READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同，**READ COMMITTED ——** **每次读取数据前都生成一个****ReadView**，**REPEATABLE READ ——** **在第一次读取数据时生成一个****ReadView**

     **小结：从上边的描述中我们可以看出来，所谓的 MVCC （Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用 READ COMMITTD 、 REPEATABLE READ 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的 读-写 、 写-读 操作并发执行，从而提升系统性能。 READ COMMITTD 、REPEATABLE READ 这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了。**

     

     

### 7 锁

1. 结构属性：

   trx信息 ：代表这个锁结构是哪个事务生成的。

   is_waiting ：代表当前事务是否在等待。

   type：Next-Key Locks/插入意向锁/...

2. 加解锁过程：

   + 事务 T1 要改动某条记录时，就生成了一个 锁结构 与该记录关联，因为之前没有别的事务为这条记录加锁，所以 is_waiting 属性就是 false ，我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续执行操作了。

   + 在事务 T1 提交之前，另一个事务 T2 也想对该记录做改动，那么先去看看有没有 锁结构 与这条记录关联，发现有一个 锁结构 与之关联后，然后也生成了一个 锁结构 与这条记录关联，不过 锁结构 的is_waiting 属性值为 true ，表示当前事务需要等待，我们把这个场景就称之为获取锁失败，或者加锁失败，或者没有成功的获取到锁

   + 在事务 T1 提交之后，就会把该事务生成的 锁结构 释放掉，然后看看还有没有别的事务在等待获取锁，发现了事务 T2 还在等待获取锁，所以把事务 T2 对应的锁结构的 is_waiting 属性设置为 false ，然后把该事务对应的线程唤醒，让它继续执行，此时事务 T2 就算获取到锁了

     > 读操作利用多版本并发控制（ MVCC ），写操作进行加锁，除非有特殊场景需要读写都加锁，比如一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行 加锁 操作，这样也就意味着 读操作和 写 操作也像 写-写 操作那样排队执行

     

     

     

3.  **一致性读**和**锁定读**

   + **事务利用 MVCC 进行的读取操作称之为 一致性读 ，或者 一致性无锁读 ，有的地方也称之为 快照读 。所有普通的 SELECT 语句（ plain SELECT ）在 READ COMMITTED 、 REPEATABLE READ 隔离级别下都算是 一致性读，一致性读 并不会对表中的任何记录做 加锁 操作，其他事务可以自由的对表中的记录做改动。**

   + 锁定读要求在读-读 情况不受影响，又要使 写-写 、 读-写 或 写-读 情况中的操作相互阻塞，mysql中用两种锁独占锁共享锁和独占锁来实现：

     + 共享锁 ，英文名： Shared Locks ，简称 S锁 。在事务要读取一条记录时，需要先获取该记录的 S锁
     + 独占锁 ，也常称 排他锁 ，英文名： Exclusive Locks ，简称 X锁 。在事务要改动一条记录时，需要先获取该记录的 X锁
     + 假如事务 T1 首先获取了一条记录的 S锁 之后，事务 T2 接着也要访问这条记录：如果事务 T2 想要再获取一个记录的 S锁 ，那么事务 T2 也会获得该锁，也就意味着事务 T1 和 T2 在该记录上同时持有 S锁 。如果事务 T2 想要再获取一个记录的 X锁 ，那么此操作会被阻塞，直到事务 T1 提交之后将 S锁 释放掉。如果事务 T1 首先获取了一条记录的 X锁 之后，那么不管事务 T2 接着想获取该记录的 S锁 还是 X锁 都会被阻塞，直到事务 T1 提交。 **总结：S锁 和 S锁 是兼容的， S锁 和 X锁 是不兼容的， X锁 和 X锁 也是不兼容的**
     + 加锁语句：S锁  SELECT ... LOCK IN SHARE MODE; X锁  SELECT ... FOR UPDATE;

     

     

     

4.  写操作

   + DELETE ：对一条记录做 DELETE 操作的过程其实是先在 B+ 树中定位到这条记录的位置，然后获取一下这条记录的 X 锁 ，然后再执行 delete mark 操作。我们也可以把这个定位待删除记录在 B+ 树中位置的过程看成是一个获取 X锁 的 锁定读 。

   + UPDATE ：在对一条记录做 UPDATE 操作时分为三种情况：如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在 B+ 树中定位到这条记录的位置，然后再获取一下记录的 X锁 ，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在 B+ 树中位置的过程看成是一个获取 X锁 的 锁定读 。如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在B+ 树中定位到这条记录的位置，然后获取一下记录的 X锁 ，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在 B+ 树中位置的过程看成是一个获取 X 锁 的 锁定读 ，新插入的记录由 INSERT 操作提供的 隐式锁 进行保护。如果修改了该记录的键值，则相当于在原录上做 DELETE 操作之后再来一次 INSERT 操作，加锁操作就需要按照 DELETE 和 INSERT 的规则进行了。

   + INSERT ：一般情况下，新插入一条记录的操作并不加锁，设计 InnoDB 的大叔通过一种称之为 隐式锁 的东东来保护这条新插入的记录在本事务提交前不被别的事务访问，更多细节我们后边看哈～

5. **多粒度锁**

   我们前边提到的 锁 都是针对记录的，也可以被称之为 行级锁 或者 行锁 ，对一条记录加锁影响的也只是这条记录而已，我们就说这个锁的粒度比较细；其实一个事务也可以在 表 级别进行加锁，自然就被称之为 表级锁 或 者 表锁 ，对一个表加锁影响整个表中的记录，我们就说这个锁的粒度比较粗。给表加的锁也可以分为 共享锁 S锁 ）和 独占锁 （ X锁 ）

   + 给表加 S锁 ：如果一个事务给表加了 S锁 ，那么别的事务可以继续获得该表的 S锁，别的事务可以继续获得该表中的某些记录的 S锁，别的事务不可以继续获得该表的 X锁，别的事务不可以继续获得该表中的某些记录的 X锁

   + 给表加 X锁 ：如果一个事务给表加了 X锁 （意味着该事务要独占这个表），那么：别的事务不可以继续获得该表的 S锁，别的事务不可以继续获得该表中的某些记录的 S锁别的事务不可以继续获得该表的 X锁，别的事务不可以继续获得该表中的某些记录的 X锁

     

   我们在对教学楼整体上锁（ 表锁 ）时，怎么知道教学楼中有没有教室已经被上锁（ 行锁 ）了呢？依次检查每一间教室门口有没有上锁？那这效率也太慢了吧！遍历是不可能遍历的，这辈子也不可能遍历的，于是乎设计

   InnoDB 的大叔们提出了一种称之为 意向锁

   + 意向共享锁，英文名： Intention Shared Lock ，简称 IS锁 。当事务准备在某条记录上加 S锁 时，需要先

     在表级别加一个 IS锁 。

   + 意向独占锁，英文名： Intention Exclusive Lock ，简称 IX锁 。当事务准备在某条记录上加 X锁 时，需要先在表级别加一个 IX锁 。

   + 当加表锁时，如果要加S锁，要查看表级有无IX锁，如果要加X锁，要看有无表级IS锁和IX锁

     >IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否
     >
     >被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的

6. **InnoDB**存储引擎中的锁
   
   + 表级锁：在InnoDB 存储引擎提供的表级 S锁 或者 X锁 是相当鸡肋，只会在一些特殊情况下，比方说崩溃恢复过程中用到。不过我们还是可以手动获取一下的，比方说在系统变量autocommit=0，innodb_table_locks =1 时，手动获取 InnoDB 存储引擎提供的表 t 的 S锁 或者 X锁 可以这么写：LOCK TABLES t READ ： InnoDB 存储引擎会对表 t 加表级别的 S锁 。LOCK TABLES t WRITE ： InnoDB 存储引擎会对表 t 加表级别的 X锁 。
   
   + 行级锁：行锁 ，也称为 记录锁 ，顾名思义就是在记录上加的锁。不过设计 InnoDB 的大叔很有才，一个 行锁 玩出了各种花样，也就是把 行锁 分成了各种类型。换句话说即使对同一条记录加 行锁 ，如果类型不同，起到的功效也是不同的
     + Record Locks：行记录锁，分为S锁和X锁
     
     + Gap Locks：间隙锁，MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。但是在使用 加锁 方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上Record Locks，于是就有了间隙锁，顾名思义间隙锁是记录的间隙加锁，使其无法在某个范围内插入数据，从而解决幻读。
     
       >原文：A gap lock is a lock on a gap between index records, or a lock on the gap before the first or after the last index record.
       >
       >译文：间隙锁是索引记录之间间隙上的锁，或者是第一个索引记录之前或最后一个索引记录之后间隙上的锁
     
     + Next-Key Locks：其实就是Record Locks+Gap Locks，即给当前行加锁，又给当前行的前后间隙加锁。
     
       >比如在查询select * from test_gaplock where id>1 and id<7 for update中一共有id=3和id=5两条记录，其中id为主键或者唯一列的情况下，会锁定范围id(1,3)，（3，5），（5，7）之间不允许插入数据，并且id=3和id=5两条记录也会被锁定。如果id不为主键或者唯一列，则有可能锁定整张表，在本次事务结束前别的事物无法插入数据。
       >
       >另外在id列为主键或者唯一列的情况下，select * from test_gaplock where id=1 for update 不会产生间隙锁，因为已经明确查询的范围只会有唯一一条数据，不需要间隙锁。
     
     + Insert Intention Locks：插入意向锁，事务在对语句加锁之前要先判断语句上有没有锁，于是就产生了插入意向锁。在1锁结构中有tyep字段来表明当前事务的锁是什么锁，插入意向锁就是其中一种所结构，它表示当前记录范围被其他事务锁定，当前事务对被锁定的记录范围有插入意向，正在等待插入（被阻塞）。插入意向锁并不会阻止别的事务继续获取该记录上任何类型的锁
     
     + 隐式锁：一个事务对新插入的记录可以不显式的加锁（生成一个锁结构），当别的事务在对这条新加的记录加 S锁 或者 X锁时，程序会先判断新纪录上的trx_id是否与要加锁的事务一致，如果不一致，则会给插入记录的事务生成一个锁结构，然后再给此事务生成一个锁结构后进入等待状态，这种方式成为隐式加锁。



---

> 作者: wang  
> URL: https://codingroam.github.io/post/mysql%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/  

