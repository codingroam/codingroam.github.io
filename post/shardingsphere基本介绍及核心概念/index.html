<!doctype html><html lang=zh-cn dir=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>ShardingSphere基本介绍及核心概念 - 想学啊你</title><meta name=keywords content="博客"><meta name=author content="roam"><meta property="og:title" content="ShardingSphere基本介绍及核心概念"><meta property="og:site_name" content="想学啊你"><meta property="og:image" content="https://codingroam.github.io/img/author.jpg"><meta name=title content="ShardingSphere基本介绍及核心概念 - 想学啊你"><meta name=description content="轻轻的你来了"><link rel="shortcut icon" href=https://codingroam.github.io/img/favicon.ico><link rel=apple-touch-icon href=https://codingroam.github.io/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://codingroam.github.io/img/apple-touch-icon.png><link href=//unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.css rel=stylesheet><link href=https://codingroam.github.io/css/main.css rel=stylesheet type=text/css><link href=https://codingroam.github.io/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-Hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>想学啊你</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>三四楼那么高了</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-active"><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/tags rel=section><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class=menu-item><a href=/categories rel=section><i class="menu-item-icon fa fa-fw fa-book"></i><br>分类</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://codingroam.github.io/post/shardingsphere%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/ itemprop=url>ShardingSphere基本介绍及核心概念</a></h1><div class=post-meta><span class=post-pushdate><i class="fa fa-calendar-o fa-fw"></i>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2023-07-24">2023-07-24</time></span>
<span class=post-category><i class="fa fa-folder-o fa-fw"></i>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/mysql itemprop=url rel=index><span itemprop=name>MySQL</span></a>
&nbsp;</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/shardingsphere itemprop=url rel=index><span itemprop=name>ShardingSphere</span></a>
&nbsp;</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8 itemprop=url rel=index><span itemprop=name>分库分表</span></a>
&nbsp;</span></span>
<span class=post-wordcount><i class="fa fa-file-word-o fa-fw"></i>
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>9325 字</span></span>
<span class=post-readtime><i class="fa fa-eye fa-fw"></i>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>19分钟</span></span>
<span id=/post/shardingsphere%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/ class="leancloud_visitors post-visitor" data-flag-title=ShardingSphere基本介绍及核心概念><i class="fa fa-binoculars fa-fw"></i>
<span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>ShardingSphere基本介绍及核心概念</p><h2 id=背景描述>背景描述</h2><ul><li>最初设计的系统只用了单机数据库</li><li>随着用户的不断增多，考虑到系统的高可用和越来越多的用户请求，开始使用数据库主从架构</li><li>当用户量级和业务进一步提升后，写请求越来越多，这时需要开始使用了分库分表</li></ul><h2 id=遇到的问题>遇到的问题</h2><ul><li>用户请求量太大 单服务器TPS、内存、IO都是有上限的，需要将请求打散分布到多个服务器</li><li>单库数据量太大 单个数据库处理能力有限；单库所在服务器的磁盘空间有限；单库上的操作IO有瓶颈</li><li>单表数据量太大 查询、插入、更新操作都会变慢，在加字段、加索引、机器迁移都会产生高负载，影响服务</li></ul><h2 id=如何解决>如何解决</h2><h3 id=垂直拆分>垂直拆分</h3><ul><li>垂直分库 微服务架构时，业务切割得足够独立，数据也会按照业务切分，保证业务数据隔离，大大提升了数据库的吞吐能力</li></ul><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/b1fd566dfce948e6bfa4ecabb6db8b11.png alt=img></p><ul><li>垂直分表 表中字段太多且包含大字段的时候，在查询时对数据库的IO、内存会受到影响，同时更新数据时，产生的binlog文件会很大，MySQL在主从同步时也会有延迟的风险 <img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/f28023180b2e4a28ae71ef3e55b529c8.png alt=img></li></ul><h3 id=水平拆分数据分片>水平拆分(数据分片)</h3><ul><li>水平分表 针对数据量巨大的单张表（比如订单表），按照规则把一张表的数据切分到多张表里面去。但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。</li></ul><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/9310b986745047ebb2cd6798dee9abb9.png alt=img></p><ul><li>水平分库 将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈</li><li>水平分库规则 不跨库、不跨表，保证同一类的数据都在同一个服务器上面。 数据在切分之前，需要考虑如何高效的进行数据获取，如果每次查询都要跨越多个节点，就需要谨慎使用。</li><li>水平分表规则</li></ul><ul>- RANGE<ul>- 时间：按照年、月、日去切分。例如order_2020、order_202005、order_20200501
- 地域：按照省或市去切分。例如order_beijing、order_shanghai、order_chengdu
- 大小：从0到1000000一个表。例如1000001-2000000放一个表，每100万放一个表</ul>- HASH<ul>- 用户ID取模 不同的业务使用的切分规则是不一样，就上面提到的切分规则，举例如下：<ul>- 站内信 用户维度：用户只能看到发送给自己的消息，其他用户是不可见的，这种情况下是按照用户ID hash分库，在用户查看历史记录翻页查询时，所有的查询请求都在同一个库内
- 用户表 范围法：以用户ID为划分依据，将数据水平切分到两个数据库实例，如：1到1000W在一张表，1000W到2000W在一张表，这种情况会出现单表的负载较高 按照用户ID HASH尽量保证用户数据均衡分到数据库中<blockquote><p>如果在登录场景下，用户输入手机号和验证码进行登录，这种情况下，登录时是不是需要扫描所有分库的信息？ 最终方案：用户信息采用ID做切分处理，同时存储用户ID和手机号的映射的关系表（新增一个关系表），关系表采用手机号进行切分。可以通过关系表根据手机号查询到对应的ID，再定位用户信息。</p></blockquote>- 流水表 时间维度：可以根据每天新增的流水来判断，选择按照年份分库，还是按照月份分库，甚至也可以按照日期分库
- 订单表 在线招聘网站中，求职者（下面统称C端用户）投递企业（下面统称B端用户）的职位产生的记录称之为订单表。在线上的业务场景中，C端用户看自己的投递记录，每次的投递到了哪个状态，B端用户查看自己收到的简历，对于合适的简历会进行下一步沟通，同一个公司内的员工可以协作处理简历。 如何能同时满足C端和B端对数据查询，不进行跨库处理？ 最终方案：为了同时满足两端用户的业务场景，采用空间换时间，将一次的投递记录存为两份，C端的投递记录以用户ID为分片键，B端收到的简历按照公司ID为分片键</ul></ul></ul>- 主键选择<ul>- UUID：本地生成，不依赖数据库，缺点就是作为主键性能太差
- SNOWFLAKE：百度UidGenerator、美团Leaf、基于SNOWFLAKE算法实现</ul>- 数据一致性<ul>- 强一致性：XA协议
- 最终一致性：TCC、saga、Seata</ul>- 数据库扩容<ul>- 成倍增加数据节点，实现平滑扩容
- 成倍扩容以后，表中的部分数据请求已被路由到其他节点上面，可以清理掉</ul>- 业务层改造<ul>- 基于代理层方式：Mycat、Sharding-Proxy、MySQL Proxy
- 基于应用层方式：Sharding-jdbc</ul>- 分库后面临的问题<ul>- 事务问题：一次投递需要插入两条记录，且分布在不同的服务器上，数据需要保障一致性。
- 跨库跨表的join问题，可以通过下面几种方式进行处理：<ul>- 全局表（字典表）：基础数据/配置数据，所有库都拷贝一份
- 字段冗余：可以使用字段冗余就不用join查询了
- 系统层组装：可以在业务层分别查询出来，然后组装起来，逻辑较复杂</ul>- 额外的数据管理负担和数据运算压力：数据库扩容、维护成本变高</ul><p>官网地址</p><p>  Apache ShardingSphere是一款开源的分布式数据库中间件组成的生态圈。它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（规划中）这3款相互独立的产品组成。 他们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。</p><p>ShardingSphere项目状态如下，目前已经更新到了5.0版本，但是本次学习任然使用4.1版本： <img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/a7cd0ed239f34d13a0debe57c3a6c0b4.png alt=img> ShardingSphere定位为关系型数据库中间件，旨在充分合理地在分布式的场景下利用关系型数据库的计算和存储能力，而并非实现一个全新的关系型数据库。 <img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/8f88a6d551d74a0eacc7db24b28fb31e.png alt=img></p><ul><li>Sharding-JDBC：被定位为轻量级Java框架，在Java的JDBC层提供的额外服务，以jar包形式使用。</li><li>Sharding-Proxy：被定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。</li><li>Sharding-Sidecar：被定位为Kubernetes或Mesos的云原生数据库代理，以DaemonSet的形式代理所有对数据库的访问。</li></ul><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/e64a0e16c86449c99ea4cfab5dd70f20.png alt=img> Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar三者区别如下：</p><p>  ShardingSphere-JDBC 采用无中心化架构，适用于 Java 开发的高性能的轻量级 OLTP 应用；ShardingSphere-Proxy 提供静态入口以及异构语言的支持，适用于 OLAP 应用以及对分片数据库进行管理和运维的场景。</p><p>  Apache ShardingSphere 是多接入端共同组成的生态圈。 通过混合使用 ShardingSphere-JDBC 和 ShardingSphere-Proxy，并采用同一注册中心统一配置分片策略，能够灵活的搭建适用于各种场景的应用系统，使得架构师更加自由地调整适合与当前业务的最佳系统架构。</p><p>ShardingSphere安装包下载：https://shardingsphere.apache.org/document/current/cn/downloads/ <img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/fed2c29f9ef040fc949d0c2cc442c6a5.png alt=img> <img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/5686dd5a67694b8c8f79c21af8a59aa2.png alt=img> 使用Git下载工程： <a href=https://github.com/apache/incubator-shardingsphere.git target=_blank rel=noopener>https://github.com/apache/incubator-shardingsphere.git</a>
<img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/1b6d05e4284a4f3b8ab144cc586276c7.png alt=img></p><p>  Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架的使用。</p><ul><li>适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</li><li>基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。</li><li>支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。</li></ul><h2 id=sharding-jdbc主要功能>Sharding-JDBC主要功能：</h2><ul><li>数据分片</li></ul><ul>- 分库、分表
- 读写分离
- 分片策略
- 分布式主键</ul>- 分布式事务<ul>- 标准化的事务接口
- XA强一致性事务
- 柔性事务</ul>- 数据库治理<ul>- 配置动态化
- 编排和治理
- 数据脱敏
- 可视化链路追踪</ul><h2 id=sharding-jdbc-内部结构>Sharding-JDBC 内部结构：</h2><p><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/ace876decf0e44088d980ad4c65fd54d.png alt=img></p><ul><li>图中黄色部分表示的是Sharding-JDBC的入口API，采用工厂方法的形式提供。 目前有ShardingDataSourceFactory和MasterSlaveDataSourceFactory两个工厂类。</li></ul><ul>- ShardingDataSourceFactory支持分库分表、读写分离操作
- MasterSlaveDataSourceFactory支持读写分离操作</ul>- 图中蓝色部分表示的是Sharding-JDBC的配置对象，提供灵活多变的配置方式。ShardingRuleConfiguration是分库分表配置的核心和入口，它可以包含多个TableRuleConfiguration和MasterSlaveRuleConfiguration。<ul>- TableRuleConfiguration封装的是表的分片配置信息，有5种配置形式对应不同的Configuration类型。
- MasterSlaveRuleConfiguration封装的是读写分离配置信息。</ul>- 图中红色部分表示的是内部对象，由Sharding-JDBC内部使用，应用开发者无需关注。Sharding-JDBC通过ShardingRuleConfiguration和MasterSlaveRuleConfiguration生成真正供ShardingDataSource和MasterSlaveDataSource使用的规则对象。ShardingDataSource和MasterSlaveDataSource实现了DataSource接口，是JDBC的完整实现方案。<h2 id=sharding-jdbc初始化流程>Sharding-JDBC初始化流程：</h2><ol><li>根据配置的信息生成Configuration对象</li><li>通过Factory会将Configuration对象转化为Rule对象</li><li>通过Factory会将Rule对象与DataSource对象封装</li><li>Sharding-JDBC使用DataSource进行分库分表和读写分离操作</li></ol><h2 id=sharding-jdbc-使用过程>Sharding-JDBC 使用过程：</h2><ul><li>引入maven依赖</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#666>&lt;</span>dependency<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#666>&lt;</span>groupId<span style=color:#666>&gt;</span>org<span style=color:#666>.</span><span style=color:#b44>apache</span><span style=color:#666>.</span><span style=color:#b44>shardingsphere</span><span style=color:#666>&lt;/</span>groupId<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#666>&lt;</span>artifactId<span style=color:#666>&gt;</span>sharding<span style=color:#666>-</span>jdbc<span style=color:#666>-</span>core<span style=color:#666>&lt;/</span>artifactId<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#666>&lt;</span>version<span style=color:#666>&gt;</span>$<span style=color:#666>{</span>latest<span style=color:#666>.</span><span style=color:#b44>release</span><span style=color:#666>.</span><span style=color:#b44>version</span><span style=color:#666>}&lt;/</span>version<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#666>&lt;/</span>dependency<span style=color:#666>&gt;</span>
</span></span></code></pre></div><p>注意: 请将${latest.release.version}更改为实际的版本号。</p><ul><li>规则配置 Sharding-JDBC可以通过Java，YAML，Spring命名空间和Spring Boot Starter四种方式配置，开发者可根据场景选择适合的配置方式。</li><li>创建DataSource 通过ShardingDataSourceFactory工厂和规则配置对象获取ShardingDataSource，然后即可通过DataSource选择使用原生JDBC开发，或者使用JPA, MyBatis等ORM工具。 DataSource dataSource = ShardingDataSourceFactory.createDataSource(dataSourceMap,shardingRuleConfig, props);</li></ul><p>官网地址</p><h2 id=表概念>表概念</h2><ul><li>真实表 数据库中真实存在的物理表。例如b_order0、b_order1</li><li>逻辑表 在分片之后，同一类表结构的名称（总成）。例如b_order。</li><li>数据节点 在分片之后，由数据源和数据表组成。例如ds0.b_order1</li><li>绑定表 指的是分片规则一致的关系表（主表、子表），例如b_order和b_order_item，均按照order_id分片，则此两个表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，可以提升关联查询效率。 b_order：b_order0、b_order1
b_order_item：b_order_item0、b_order_item1</li></ul><p>select * from b_order o join b_order_item i on(o.order_id=i.order_id)where o.order_id in (10,11); 在不配置绑定表关系时，假设分片键order_id将数值10路由至第0片，将数值11路由至第1片，那么路由后的SQL应该为4条，它们呈现为笛卡尔积： SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);</p><p>SELECT i.* FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);</p><p>SELECT i.* FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);</p><p>SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11); 在配置绑定表关系后，路由的SQL应该为2条： SELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);</p><p>SELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);</p><ul><li>广播表 在使用中，有些表没必要做分片，例如字典表、省份信息等，因为他们数据量不大，而且这种表可能需要与海量数据的表进行关联查询。广播表会在不同的数据节点上进行存储，存储的表结构和数据完全相同。</li></ul><h2 id=分片概念>分片概念</h2><h3 id=分片键>分片键</h3><p>  用于分片的数据库字段，是将数据库(表)水平拆分的关键字段。例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。 SQL中如果无分片字段，将执行全路由，性能较差。 除了对单分片字段的支持，ShardingSphere也支持根据多个字段进行分片。</p><h3 id=分片算法shardingalgorithm>分片算法（ShardingAlgorithm）</h3><p>  由于分片算法和业务实现紧密相关，因此并未提供内置分片算法，而是通过分片策略将各种场景提炼出来，提供更高层级的抽象，并提供接口让应用开发者自行实现分片算法。目前提供4种分片算法。</p><ul><li>精确分片算法PreciseShardingAlgorithm 用于处理使用单一键作为分片键的=与IN进行分片的场景。</li><li>范围分片算法RangeShardingAlgorithm 用于处理使用单一键作为分片键的BETWEEN AND、>、&lt;、>=、&lt;=进行分片的场景。</li><li>复合分片算法ComplexKeysShardingAlgorithm 用于处理使用多键作为分片键进行分片的场景，多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。</li><li>Hint分片算法HintShardingAlgorithm 用于处理使用Hint行分片的场景。对于分片字段非SQL决定，而由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段。例：内部系统，按照员工登录主键分库，而数据库中并无此字段。SQL Hint支持通过Java API和SQL注释两种方式使用。</li></ul><h3 id=分片策略>分片策略</h3><p>  包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。目前提供5种分片策略。</p><ul><li>标准分片策略 对应StandardShardingStrategy。提供对SQL语句中的=, >, &lt;, >=, &lt;=, IN和BETWEEN AND的分片操作支持。StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理=和IN的分片。RangeShardingAlgorithm是可选的，用于处理BETWEEN AND, >, &lt;, >=, &lt;=分片，如果不配置RangeShardingAlgorithm，SQL中的BETWEEN AND将按照全库路由处理。</li><li>复合分片策略 对应ComplexShardingStrategy。复合分片策略。提供对SQL语句中的=, >, &lt;, >=, &lt;=, IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度。</li><li>行表达式分片策略 对应InlineShardingStrategy。使用Groovy的表达式，提供对SQL语句中的=和IN的分片操作支持，只支持单分片键。对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: t_user_$->{u_id % 8} 表示t_user表根据u_id模8，而分成8张表，表名称为t_user_0到t_user_7。</li><li>Hint分片策略 对应HintShardingStrategy。通过Hint指定分片值而非从SQL中提取分片值的方式进行分片的策略。</li><li>不分片策略 对应NoneShardingStrategy。不分片的策略。</li></ul><h3 id=分片策略配置>分片策略配置</h3><p>对于分片策略存有数据源分片策略和表分片策略两种维度，两种策略的API完全相同。</p><ul><li>数据源分片策略 用于配置数据被分配的目标数据源。</li><li>表分片策略 用于配置数据被分配的目标表，由于表存在与数据源内，所以表分片策略是依赖数据源分片 策略结果的。</li></ul><h2 id=流程剖析>流程剖析</h2><p>ShardingSphere 3个产品的数据分片功能主要流程是完全一致的，如下图所示。 <img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/a026f9d13b8e49ec8e47545d8842666d.png alt=img></p><ul><li>SQL解析 SQL解析分为词法解析和语法解析。 先通过词法解析器将SQL拆分为一个个不可再分的单词。再使用语法解析器对SQL进行理解，并最终提炼出解析上下文。 Sharding-JDBC采用不同的解析器对SQL进行解析，解析器类型如下：</li></ul><ul>- MySQL解析器
- Oracle解析器
- SQLServer解析器
- PostgreSQL解析器
- 默认SQL解析器</ul>- 查询优化 负责合并和优化分片条件，如OR等。
- SQL路由 根据解析上下文匹配用户配置的分片策略，并生成路由路径。目前支持分片路由和广播路由。
- SQL改写 将SQL改写为在真实数据库中可以正确执行的语句。SQL改写分为正确性改写和优化改写。
- SQL执行 通过多线程执行器异步执行SQL。
- 结果归并 将多个执行结果集归并以便于通过统一的JDBC接口输出。结果归并包括流式归并、内存归并和使 用装饰者模式的追加归并这几种方式。<h2 id=sql使用规范>SQL使用规范</h2><ul><li>SQL使用规范</li></ul><ul>- 支持项<ul>- 路由至单数据节点时，目前MySQL数据库100%全兼容，其他数据库完善中。
- 路由至多数据节点时，全面支持DQL、DML、DDL、DCL、TCL。支持分页、去重、排序、分组、聚合、关联查询（不支持跨库关联）。以下用最为复杂的查询为例：<p>​</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#666>-</span><span style=color:#bbb> </span>SELECT<span>主语句</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#a2f;font-weight:700>SELECT</span><span style=color:#bbb> </span>select_expr<span style=color:#bbb> </span>[,<span style=color:#bbb> </span>select_expr<span style=color:#bbb> </span>...]<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>FROM</span><span style=color:#bbb> </span>table_reference<span style=color:#bbb> </span>[,<span style=color:#bbb> </span>table_reference<span style=color:#bbb> </span>...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span>[<span style=color:#a2f;font-weight:700>WHERE</span><span style=color:#bbb> </span>predicates]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span>[<span style=color:#a2f;font-weight:700>GROUP</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>BY</span><span style=color:#bbb> </span><span>{</span>col_name<span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>position</span><span>}</span><span style=color:#bbb> </span>[<span style=color:#a2f;font-weight:700>ASC</span><span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>DESC</span>],<span style=color:#bbb> </span>...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span>[<span style=color:#a2f;font-weight:700>ORDER</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>BY</span><span style=color:#bbb> </span><span>{</span>col_name<span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>position</span><span>}</span><span style=color:#bbb> </span>[<span style=color:#a2f;font-weight:700>ASC</span><span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>DESC</span>],<span style=color:#bbb> </span>...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>	</span>[<span style=color:#a2f;font-weight:700>LIMIT</span><span style=color:#bbb> </span><span>{</span>[<span style=color:#a2f;font-weight:700>offset</span>,]<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>row_count</span><span style=color:#bbb> </span><span style=color:#666>|</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>row_count</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>OFFSET</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>offset</span><span>}</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li>不支持项</li></ul><ul>- 路由至多数据节点
- 不支持CASE WHEN、HAVING、UNION (ALL)，有限支持子查询。</ul><p>除了分页子查询的支持之外(详情请参考分页)，也支持同等模式的子查询。无论嵌套多少层，ShardingSphere都可以解析至第一个包含数据表的子查询，一旦在下层嵌套中再次找到包含数据表的子查询将直接抛出解析异常。</p><p>例如，以下子查询可以支持：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SELECT <span style=color:#00a000>COUNT</span><span style=color:#666>(*)</span> FROM <span style=color:#666>(</span>SELECT <span style=color:#666>*</span> FROM t_order o<span style=color:#666>)</span>
</span></span></code></pre></div><p>以下子查询不支持：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SELECT <span style=color:#00a000>COUNT</span><span style=color:#666>(*)</span> FROM <span style=color:#666>(</span>SELECT <span style=color:#666>*</span> FROM t_order o WHERE o<span style=color:#666>.</span><span style=color:#b44>id</span> <span style=color:#00a000>IN</span> <span style=color:#666>(</span>SELECT id FROM t_order WHERE status <span style=color:#666>=</span> <span style=color:#666>?))</span>
</span></span></code></pre></div><p>简单来说，通过子查询进行非功能需求，在大部分情况下是可以支持的。比如分页、统计总数等；而通过子查询实现业务查询当前并不能支持。</p><ul><li>由于归并的限制，子查询中包含聚合函数目前无法支持。</li><li>不支持包含schema的SQL。因为ShardingSphere的理念是像使用一个数据源一样使用多数据源，因此对SQL的访问都是在同一个逻辑schema之上。</li><li>当分片键处于运算表达式或函数中的SQL时，将采用全路由的形式获取结果。 例如下面SQL，create_time为分片键：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SELECT <span style=color:#666>*</span> FROM t_order WHERE <span style=color:#00a000>to_date</span><span style=color:#666>(</span>create_time<span style=color:#666>,</span> <span>&#39;</span>yyyy<span style=color:#666>-</span>mm<span style=color:#666>-</span>dd<span>&#39;</span><span style=color:#666>)</span> <span style=color:#666>=</span> <span>&#39;</span><span style=color:#666>2019</span><span style=color:#666>-</span><span style=color:#666>01</span><span style=color:#666>-</span><span style=color:#666>01</span><span>&#39;</span><span style=color:#666>;</span>
</span></span></code></pre></div><p>由于ShardingSphere只能通过SQL字面提取用于分片的值，因此当分片键处于运算表达式或函数中时，ShardingSphere无法提前获取分片键位于数据库中的值，从而无法计算出真正的分片值。</p><p>当出现此类分片键处于运算表达式或函数中的SQL时，ShardingSphere将采用全路由的形式获取结果。 不支持的SQL示例：</p><h2 id=分页查询>分页查询</h2><p>完全支持MySQL和Oracle的分页查询，SQLServer由于分页查询较为复杂，仅部分支持.</p><ul><li>性能瓶颈： 查询偏移量过大的分页会导致数据库获取数据性能低下，以MySQL为例：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SELECT <span style=color:#666>*</span> FROM t_order ORDER BY id LIMIT <span style=color:#666>1000000</span><span style=color:#666>,</span> <span style=color:#666>10</span>
</span></span></code></pre></div><p>这句SQL会使得MySQL在无法利用索引的情况下跳过1000000条记录后，再获取10条记录，其性能可想而知。 而在分库分表的情况下（假设分为2个库），为了保证数据的正确性，SQL会改写为：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SELECT <span style=color:#666>*</span> FROM t_order ORDER BY id LIMIT <span style=color:#666>0</span><span style=color:#666>,</span> <span style=color:#666>1000010</span>
</span></span></code></pre></div><p>即将偏移量前的记录全部取出，并仅获取排序后的最后10条记录。这会在数据库本身就执行很慢的情况下，进一步加剧性能瓶颈。 因为原SQL仅需要传输10条记录至客户端，而改写之后的SQL则会传输1,000,010 * 2的记录至客户端。</p><ul><li>ShardingSphere的优化 ShardingSphere进行了2个方面的优化。</li></ul><ul>- 首先，采用流式处理 + 归并排序的方式来避免内存的过量占用。由于SQL改写不可避免的占用了额外的带宽，但并不会导致内存暴涨。 与直觉不同，大多数人认为ShardingSphere会将1,000,010 * 2记录全部加载至内存，进而占用大量内存而导致内存溢出。 但由于每个结果集的记录是有序的，因此ShardingSphere每次比较仅获取各个分片的当前结果集记录，驻留在内存中的记录仅为当前路由到的分片的结果集的当前游标指向而已。 对于本身即有序的待排序对象，归并排序的时间复杂度仅为O(n)，性能损耗很小。
- 其次，ShardingSphere对仅落至单分片的查询进行进一步优化。 落至单分片查询的请求并不需要改写SQL也可以保证记录的正确性，因此在此种情况下，ShardingSphere并未进行SQL改写，从而达到节省带宽的目的。</ul>- 分页方案优化 由于LIMIT并不能通过索引查询数据，因此如果可以保证ID的连续性，通过ID进行分页是比较好的解决方案：<div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SELECT <span style=color:#666>*</span> FROM t_order WHERE id <span style=color:#666>&gt;</span> <span style=color:#666>100000</span> AND id <span style=color:#666>&lt;=</span> <span style=color:#666>100010</span> ORDER BY id
</span></span></code></pre></div><p>或通过记录上次查询结果的最后一条记录的ID进行下一页的查询：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SELECT <span style=color:#666>*</span> FROM t_order WHERE id <span style=color:#666>&gt;</span> <span style=color:#666>100000</span> LIMIT <span style=color:#666>10</span>
</span></span></code></pre></div><h2 id=行表达式>行表达式</h2><ul><li>Inline行表达式 InlineShardingStrategy：采用Inline行表达式进行分片的配置。 Inline是可以简化数据节点和分片算法配置信息。主要是解决配置简化、配置一体化。</li></ul><p><strong>语法格式：</strong> 行表达式的使用非常直观，只需要在配置中使用e x p r e s s i o n 或 { expression }或 expression或->{ expression }标识行表达式即可。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>$<span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>[</span><span>&#39;</span>online<span>&#39;</span><span style=color:#666>,</span> <span>&#39;</span>offline<span>&#39;</span><span style=color:#666>]}</span>_table$<span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>1..3</span><span style=color:#666>}</span>
</span></span></code></pre></div><p>最终会解析为：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>online_table1<span style=color:#666>,</span> online_table2<span style=color:#666>,</span> online_table3<span style=color:#666>,</span> offline_table1<span style=color:#666>,</span> offline_table2<span style=color:#666>,</span> offline_table3
</span></span></code></pre></div><p><strong>配置数据节点:</strong> 对于均匀分布的数据节点，如果数据结构如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>db0
</span></span><span style=display:flex><span>  <span>├──</span> t_order0 
</span></span><span style=display:flex><span>  <span>└──</span> t_order1 
</span></span><span style=display:flex><span>db1
</span></span><span style=display:flex><span>  <span>├──</span> t_order0 
</span></span><span style=display:flex><span>  <span>└──</span> t_order1
</span></span></code></pre></div><p>用行表达式可以简化为：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>db$<span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>0..1</span><span style=color:#666>}.</span><span style=color:#b44>t_order$</span><span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>0..1</span><span style=color:#666>}</span>
</span></span></code></pre></div><p>或者</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>db$<span style=color:#666>-&gt;{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>0..1</span><span style=color:#666>}.</span><span style=color:#b44>t_order$</span><span style=color:#666>-&gt;{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>0..1</span><span style=color:#666>}</span>
</span></span></code></pre></div><p>对于自定义的数据节点，如果数据结构如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>db0
</span></span><span style=display:flex><span>  <span>├──</span> t_order0 
</span></span><span style=display:flex><span>  <span>└──</span> t_order1 
</span></span><span style=display:flex><span>db1
</span></span><span style=display:flex><span>  <span>├──</span> t_order2
</span></span><span style=display:flex><span>  <span>├──</span> t_order3
</span></span><span style=display:flex><span>  <span>└──</span> t_order4
</span></span></code></pre></div><p>用行表达式可以简化为：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>db0<span style=color:#666>.</span><span style=color:#b44>t_order$</span><span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>0..1</span><span style=color:#666>},</span>db1<span style=color:#666>.</span><span style=color:#b44>t_order$</span><span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>2..4</span><span style=color:#666>}</span>
</span></span></code></pre></div><p>或者</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>db0<span style=color:#666>.</span><span style=color:#b44>t_order$</span><span style=color:#666>-&gt;{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>0..1</span><span style=color:#666>},</span>db1<span style=color:#666>.</span><span style=color:#b44>t_order$</span><span style=color:#666>-&gt;{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>2..4</span><span style=color:#666>}</span>
</span></span></code></pre></div><ul><li>分片算法配置 对于只有一个分片键的使用=和IN进行分片的SQL，可以使用行表达式代替编码方式配置。 行表达式内部的表达式本质上是一段Groovy代码，可以根据分片键进行计算的方式，返回相应的真实数据源或真实表名称。 例如：分为10个库，尾数为0的路由到后缀为0的数据源， 尾数为1的路由到后缀为1的数据源，以此类推。用于表示分片算法的行表达为： ds${id % 10}</li></ul><p>或者</p><p>ds$->{id % 10} 结果为：ds0、ds1、ds2… ds9</p><h2 id=分布式主键>分布式主键</h2><p>ShardingSphere不仅提供了内置的分布式主键生成器，例如UUID、SNOWFLAKE，还抽离出分布式主键生成器的接口，方便用户自行实现自定义的自增主键生成器。</p><p><strong>内置主键生成器：</strong></p><ul><li>UUID 采用UUID.randomUUID()的方式产生分布式主键。</li><li>SNOWFLAKE 在分片规则配置模块可配置每个表的主键生成策略，默认使用雪花算法，生成64bit的长整型数据，详细规则参考下面的官网地址。 <a href=https://shardingsphere.apache.org/document/legacy/4.x/document/cn/features/sharding/other-features/key-generator/ target=_blank rel=noopener>https://shardingsphere.apache.org/document/legacy/4.x/document/cn/features/sharding/other-features/key-generator/</a></li></ul><p><strong>自定义主键生成器：</strong></p><ul><li>自定义主键类，实现ShardingKeyGenerator接口</li><li>按SPI规范配置自定义主键类 在Apache ShardingSphere中，很多功能实现类的加载方式是通过SPI注入的方式完成的。注意：在resources目录下新建META-INF文件夹，再新建services文件夹，然后新建文件的名字为org.apache.shardingsphere.spi.keygen.ShardingKeyGenerator，打开文件，复制自定义主键类全路径到文件中保存。</li><li>自定义主键类应用配置 #对应主键字段名
spring.shardingsphere.sharding.tables.t_book.key-generator.column=id
#对应主键类getType返回内容
spring.shardingsphere.sharding.tables.t_book.keygenerator.type=SELFKEY</li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/mysql rel=tag title=MySQL>#MySQL#</a>
<a href=/tags/shardingsphere rel=tag title=ShardingSphere>#ShardingSphere#</a>
<a href=/tags/%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8 rel=tag title=分库分表>#分库分表#</a>
<a href=/tags/%e4%b8%ad%e9%97%b4%e4%bb%b6 rel=tag title=中间件>#中间件#</a>
<a href=/tags/learning rel=tag title=Learning>#Learning#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>QQ扫一扫交流</div></div><div class=article-copyright-info><p><span>标题：</span>ShardingSphere基本介绍及核心概念</p><p><span>链接：</span>https://codingroam.github.io/post/shardingsphere%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</p><p><span>作者：</span>roam</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"></div><div class="post-nav-prev post-nav-item"><a href=https://codingroam.github.io/post/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3canal%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/ rel=prev title=Canal基础操作>Canal基础操作
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.png alt=roam><p class=site-author-name itemprop=name>roam</p><p class="site-description motion-element" itemprop=description>以为打得赢我啊你</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>56</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>21</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>42</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/wk123456/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://www.zhihu.com/ target=_blank title=知乎><i class="fa fa-fw fa-globe"></i>
知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class=links-of-blogroll-title><i class="fa fa-fw fa-globe"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://nutzam.com/ title=Nutz target=_blank>Nutz</a></li><li class=links-of-blogroll-item><a href=https://jfinal.com/ title=JFinal target=_blank>JFinal</a></li><li class=links-of-blogroll-item><a href=http://wendal.net/ title=Wendal target=_blank>Wendal</a></li><li class=links-of-blogroll-item><a href=https://www.liaoxuefeng.com/ title=廖雪峰 target=_blank>廖雪峰</a></li></ul></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/learning>Learning
<sup>27</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/java>Java
<sup>9</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/mysql>Mysql
<sup>9</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/linux>Linux
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6>中间件
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/problem-solving>Problem solving
<sup>7</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/docker>Docker
<sup>6</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/redis>Redis
<sup>6</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/hands-on>Hands on
<sup>5</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/git>Git
<sup>4</sup></a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>想学啊你</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.115.4</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=https://gitee.com/ style=font-weight:700 target=_blank>Gitee 仓库</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href=http://beian.miit.gov.cn target=_blank>粤 ICP 备 18047355 号</a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//unpkg.com/jquery@2.1.4/dist/jquery.min.js></script>
<script type=text/javascript src=https://codingroam.github.io/js/search.js></script>
<script type=text/javascript src=https://codingroam.github.io/js/affix.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".footer").outerHeight(!0),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var e,t,n,s,o=$(".header-inner").height()+10;$("#sidebar").css({"margin-top":o}).show(),t=parseInt($("#sidebar").css("margin-top")),n=parseInt($(".sidebar-inner").css("height")),e=t+n,s=$(".content-wrap").height(),s<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script type=text/javascript>const locale={placeholder:"欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^"};$(function(){detectIE()>0?$.getScript(document.location.protocol+"//unpkg.com/@waline/client@1.6.0/dist/Waline.min.js",function(){new Waline({el:"#wcomments",visitor:!0,emoji:[],wordLimit:"200",uploadImage:!1,locale,requiredMeta:["nick","mail"],serverURL:"Your WalineSerURL",lang:"zh-cn"})}):$("#wcomments").html("抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。")})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script>
<script>(function(){var t,e=document.createElement("script"),n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>