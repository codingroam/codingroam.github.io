<!doctype html><html lang=zh-cn dir=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>TCC 分布式事务 - 想学啊你</title><meta name=keywords content="博客"><meta name=author content="roam"><meta property="og:title" content="TCC 分布式事务"><meta property="og:site_name" content="想学啊你"><meta property="og:image" content="https://codingroam.github.io/img/author.jpg"><meta name=title content="TCC 分布式事务 - 想学啊你"><meta name=description content="轻轻的你来了"><link rel="shortcut icon" href=https://codingroam.github.io/img/favicon.ico><link rel=apple-touch-icon href=https://codingroam.github.io/img/apple-touch-icon.png><link rel=apple-touch-icon-precomposed href=https://codingroam.github.io/img/apple-touch-icon.png><link href=//unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.css rel=stylesheet><link href=https://codingroam.github.io/css/main.css rel=stylesheet type=text/css><link href=https://codingroam.github.io/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-Hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>想学啊你</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>三四楼那么高了</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-active"><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class=menu-item><a href=/tags rel=section><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class=menu-item><a href=/categories rel=section><i class="menu-item-icon fa fa-fw fa-book"></i><br>分类</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline"><a class=post-title-link href=https://codingroam.github.io/post/tcc-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/ itemprop=url>TCC 分布式事务</a></h1><div class=post-meta><span class=post-pushdate><i class="fa fa-calendar-o fa-fw"></i>
<span class=post-meta-item-text>时间：</span>
<time itemprop=dateCreated datetime=2016-03-22T13:04:35+08:00 content="2023-09-25">2023-09-25</time></span>
<span class=post-category><i class="fa fa-folder-o fa-fw"></i>
<span class=post-meta-item-text>分类：</span>
<span itemprop=about itemscope itemtype=https://schema.org/Thing><a class=post-category-a href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1 itemprop=url rel=index><span itemprop=name>分布式事务</span></a>
&nbsp;</span></span>
<span class=post-wordcount><i class="fa fa-file-word-o fa-fw"></i>
<span class=post-meta-item-text>字数：</span>
<span class=leancloud-world-count>8940 字</span></span>
<span class=post-readtime><i class="fa fa-eye fa-fw"></i>
<span class=post-meta-item-text>阅读：</span>
<span class=leancloud-view-count>18分钟</span></span>
<span id=/post/tcc-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/ class="leancloud_visitors post-visitor" data-flag-title="TCC 分布式事务"><i class="fa fa-binoculars fa-fw"></i>
<span class=post-meta-item-text>阅读次数：</span>
<span class=leancloud-visitors-count></span></span></div></header><div class=post-body itemprop=articleBody><p>TCC 分布式事务</p><p>之前网上看到很多写分布式事务的文章，不过大多都是将分布式事务各种技术方案简单介绍一下。很多朋友看了还是不知道分布式事务到底怎么回事，在项目里到底如何使用。</p><p>所以这篇文章，就用大白话 + 手工绘图，并结合一个电商系统的案例实践，来给大家讲清楚到底什么是 TCC 分布式事务。</p><h1 id=业务场景介绍业务场景介绍>业务场景介绍<a href=#%e4%b8%9a%e5%8a%a1%e5%9c%ba%e6%99%af%e4%bb%8b%e7%bb%8d>#</a></h1><p>咱们先来看看业务场景，假设你现在有一个电商系统，里面有一个支付订单的场景。</p><p><a href=https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181124221344003-1003664855.png target=_blank rel=noopener><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/1162587-20181124221344003-1003664855.png alt></a></p><p>那对一个订单支付之后，我们需要做下面的步骤：</p><ul><li>更改订单的状态为 “已支付”</li><li>扣减商品库存</li><li>给会员增加积分</li><li>创建销售出库单通知仓库发货</li></ul><p>这是一系列比较真实的步骤，无论大家有没有做过电商系统，应该都能理解。</p><h1 id=进一步思考进一步思考>进一步思考<a href=#%e8%bf%9b%e4%b8%80%e6%ad%a5%e6%80%9d%e8%80%83>#</a></h1><p>好，业务场景有了，现在我们要更进一步，实现一个 TCC 分布式事务的效果。</p><p>什么意思呢？也就是说，[1] 订单服务 - 修改订单状态，[2] 库存服务 - 扣减库存，[3] 积分服务 - 增加积分，[4] 仓储服务 - 创建销售出库单。</p><p>上述这几个步骤，要么一起成功，要么一起失败，必须是一个整体性的事务。</p><p>举个例子，现在订单的状态都修改为 “已支付” 了，结果库存服务扣减库存失败。那个商品的库存原来是 100 件，现在卖掉了 2 件，本来应该是 98 件了。</p><p>结果呢？由于库存服务操作数据库异常，导致库存数量还是 100。这不是在坑人么，当然不能允许这种情况发生了！</p><p>但是如果你不用 TCC 分布式事务方案的话，就用个 Spring Cloud 开发这么一个微服务系统，很有可能会干出这种事儿来。</p><p>我们来看看下面的这个图，直观的表达了上述的过程：</p><p><a href=https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181124221516538-2117168183.png target=_blank rel=noopener><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/1162587-20181124221516538-2117168183.png alt></a></p><p>所以说，我们有必要使用 TCC 分布式事务机制来保证各个服务形成一个整体性的事务。</p><p>上面那几个步骤，要么全部成功，如果任何一个服务的操作失败了，就全部一起回滚，撤销已经完成的操作。</p><p>比如说库存服务要是扣减库存失败了，那么订单服务就得撤销那个修改订单状态的操作，然后得停止执行增加积分和通知出库两个操作。</p><p>说了那么多，老规矩，给大家上一张图，大伙儿顺着图来直观的感受一下：</p><p><a href=https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181124221639782-279567864.png target=_blank rel=noopener><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/1162587-20181124221639782-279567864.png alt></a></p><h1 id=落地实现-tcc-分布式事务落地实现-tcc-分布式事务>落地实现 TCC 分布式事务<a href=#%e8%90%bd%e5%9c%b0%e5%ae%9e%e7%8e%b0-tcc-%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1>#</a></h1><p>那么现在到底要如何来实现一个 TCC 分布式事务，使得各个服务，要么一起成功？要么一起失败呢？</p><p>大家稍安勿躁，我们这就来一步一步的分析一下。咱们就以一个 Spring Cloud 开发系统作为背景来解释。</p><h2 id=tcc-实现阶段一trytcc-实现阶段一try>TCC 实现阶段一：Try<a href=#tcc-%e5%ae%9e%e7%8e%b0%e9%98%b6%e6%ae%b5%e4%b8%80try>#</a></h2><p>首先，订单服务那儿，它的代码大致来说应该是这样子的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>public class OrderService {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // 库存服务
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Autowired
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    private InventoryService inventoryService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // 积分服务
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Autowired
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    private CreditService creditService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // 仓储服务
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    @Autowired
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    private WmsService wmsService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // 对这个订单完成支付
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    public void pay(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //对本地的的订单数据库修改订单状态为&#34;已支付&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        orderDAO.updateStatus(OrderStatus.PAYED);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //调用库存服务扣减库存
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        inventoryService.reduceStock();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //调用积分服务增加积分
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        creditService.addCredit();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //调用仓储服务通知发货
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        wmsService.saleDelivery();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果你之前看过 Spring Cloud 架构原理那篇文章，同时对 Spring Cloud 有一定的了解的话，应该是可以理解上面那段代码的。</p><p>其实就是订单服务完成本地数据库操作之后，通过 Spring Cloud 的 Feign 来调用其他的各个服务罢了。</p><p>但是光是凭借这段代码，是不足以实现 TCC 分布式事务的啊？！兄弟们，别着急，我们对这个订单服务修改点儿代码好不好。</p><p>首先，上面那个订单服务先把自己的状态修改为：OrderStatus.UPDATING。</p><p>这是啥意思呢？也就是说，在 pay() 那个方法里，你别直接把订单状态修改为已支付啊！你先把订单状态修改为 UPDATING，也就是修改中的意思。</p><p>这个状态是个没有任何含义的这么一个状态，代表有人正在修改这个状态罢了。</p><p>然后呢，库存服务直接提供的那个 reduceStock() 接口里，也别直接扣减库存啊，你可以是冻结掉库存。</p><p>举个例子，本来你的库存数量是 100，你别直接 100 - 2 = 98，扣减这个库存！</p><p>你可以把可销售的库存：100 - 2 = 98，设置为 98 没问题，然后在一个单独的冻结库存的字段里，设置一个 2。也就是说，有 2 个库存是给冻结了。</p><p>积分服务的 addCredit() 接口也是同理，别直接给用户增加会员积分。你可以先在积分表里的一个预增加积分字段加入积分。</p><p>比如：用户积分原本是 1190，现在要增加 10 个积分，别直接 1190 + 10 = 1200 个积分啊！</p><p>你可以保持积分为 1190 不变，在一个预增加字段里，比如说 prepare_add_credit 字段，设置一个 10，表示有 10 个积分准备增加。</p><p>仓储服务的 saleDelivery() 接口也是同理啊，你可以先创建一个销售出库单，但是这个销售出库单的状态是 “UNKNOWN”。</p><p>也就是说，刚刚创建这个销售出库单，此时还不确定它的状态是什么呢！</p><p>上面这套改造接口的过程，其实就是所谓的 TCC 分布式事务中的第一个 T 字母代表的阶段，也就是 Try 阶段。</p><p>总结上述过程，如果你要实现一个 TCC 分布式事务，首先你的业务的主流程以及各个接口提供的业务含义，不是说直接完成那个业务操作，而是完成一个 Try 的操作。</p><p>这个操作，一般都是锁定某个资源，设置一个预备类的状态，冻结部分数据，等等，大概都是这类操作。</p><p>咱们来一起看看下面这张图，结合上面的文字，再来捋一捋整个过程：</p><p><a href=https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181124231758883-311791121.png target=_blank rel=noopener><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/1162587-20181124231758883-311791121.png alt></a></p><h2 id=tcc-实现阶段二confirmtcc-实现阶段二confirm>TCC 实现阶段二：Confirm<a href=#tcc-%e5%ae%9e%e7%8e%b0%e9%98%b6%e6%ae%b5%e4%ba%8cconfirm>#</a></h2><p>然后就分成两种情况了，第一种情况是比较理想的，那就是各个服务执行自己的那个 Try 操作，都执行成功了，Bingo！</p><p>这个时候，就需要依靠 TCC 分布式事务框架来推动后续的执行了。这里简单提一句，如果你要玩儿 TCC 分布式事务，必须引入一款 TCC 分布式事务框架，比如国内开源的 ByteTCC、Himly、TCC-transaction。</p><p>否则的话，感知各个阶段的执行情况以及推进执行下一个阶段的这些事情，不太可能自己手写实现，太复杂了。</p><p>如果你在各个服务里引入了一个 TCC 分布式事务的框架，订单服务里内嵌的那个 TCC 分布式事务框架可以感知到，各个服务的 Try 操作都成功了。</p><p>此时，TCC 分布式事务框架会控制进入 TCC 下一个阶段，第一个 C 阶段，也就是 Confirm 阶段。</p><p>为了实现这个阶段，你需要在各个服务里再加入一些代码。比如说，订单服务里，你可以加入一个 Confirm 的逻辑，就是正式把订单的状态设置为 “已支付” 了，大概是类似下面这样子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>public class OrderServiceConfirm {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    public void pay(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        orderDao.updateStatus(OrderStatus.PAYED);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>库存服务也是类似的，你可以有一个 InventoryServiceConfirm 类，里面提供一个 reduceStock() 接口的 Confirm 逻辑，这里就是将之前冻结库存字段的 2 个库存扣掉变为 0。</p><p>这样的话，可销售库存之前就已经变为 98 了，现在冻结的 2 个库存也没了，那就正式完成了库存的扣减。</p><p>积分服务也是类似的，可以在积分服务里提供一个 CreditServiceConfirm 类，里面有一个 addCredit() 接口的 Confirm 逻辑，就是将预增加字段的 10 个积分扣掉，然后加入实际的会员积分字段中，从 1190 变为 1120。</p><p>仓储服务也是类似，可以在仓储服务中提供一个 WmsServiceConfirm 类，提供一个 saleDelivery() 接口的 Confirm 逻辑，将销售出库单的状态正式修改为 “已创建”，可以供仓储管理人员查看和使用，而不是停留在之前的中间状态“UNKNOWN” 了。</p><p>好了，上面各种服务的 Confirm 的逻辑都实现好了，一旦订单服务里面的 TCC 分布式事务框架感知到各个服务的 Try 阶段都成功了以后，就会执行各个服务的 Confirm 逻辑。</p><p>订单服务内的 TCC 事务框架会负责跟其他各个服务内的 TCC 事务框架进行通信，依次调用各个服务的 Confirm 逻辑。然后，正式完成各个服务的所有业务逻辑的执行。</p><p>同样，给大家来一张图，顺着图一起来看看整个过程：</p><p><a href=https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181124232142806-1339085171.png target=_blank rel=noopener><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/1162587-20181124232142806-1339085171.png alt></a></p><h2 id=tcc-实现阶段三canceltcc-实现阶段三cancel>TCC 实现阶段三：Cancel<a href=#tcc-%e5%ae%9e%e7%8e%b0%e9%98%b6%e6%ae%b5%e4%b8%89cancel>#</a></h2><p>好，这是比较正常的一种情况，那如果是异常的一种情况呢？</p><p>举个例子：在 Try 阶段，比如积分服务吧，它执行出错了，此时会怎么样？</p><p>那订单服务内的 TCC 事务框架是可以感知到的，然后它会决定对整个 TCC 分布式事务进行回滚。</p><p>也就是说，会执行各个服务的第二个 C 阶段，Cancel 阶段。同样，为了实现这个 Cancel 阶段，各个服务还得加一些代码。</p><p>首先订单服务，它得提供一个 OrderServiceCancel 的类，在里面有一个 pay() 接口的 Cancel 逻辑，就是可以将订单的状态设置为 “CANCELED”，也就是这个订单的状态是已取消。</p><p>库存服务也是同理，可以提供 reduceStock() 的 Cancel 逻辑，就是将冻结库存扣减掉 2，加回到可销售库存里去，98 + 2 = 100。</p><p>积分服务也需要提供 addCredit() 接口的 Cancel 逻辑，将预增加积分字段的 10 个积分扣减掉。</p><p>仓储服务也需要提供一个 saleDelivery() 接口的 Cancel 逻辑，将销售出库单的状态修改为 “CANCELED” 设置为已取消。</p><p>然后这个时候，订单服务的 TCC 分布式事务框架只要感知到了任何一个服务的 Try 逻辑失败了，就会跟各个服务内的 TCC 分布式事务框架进行通信，然后调用各个服务的 Cancel 逻辑。</p><p>大家看看下面的图，直观的感受一下：</p><p><a href=https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181124232236571-484288052.png target=_blank rel=noopener><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/1162587-20181124232236571-484288052.png alt></a></p><h2 id=总结与思考总结与思考>总结与思考<a href=#%e6%80%bb%e7%bb%93%e4%b8%8e%e6%80%9d%e8%80%83>#</a></h2><p>好了，兄弟们，聊到这儿，基本上大家应该都知道 TCC 分布式事务具体是怎么回事了！</p><p>总结一下，你要玩儿 TCC 分布式事务的话：首先需要选择某种 TCC 分布式事务框架，各个服务里就会有这个 TCC 分布式事务框架在运行。</p><p>然后你原本的一个接口，要改造为 3 个逻辑，Try-Confirm-Cancel：</p><ul><li>先是服务调用链路依次执行 Try 逻辑。</li><li>如果都正常的话，TCC 分布式事务框架推进执行 Confirm 逻辑，完成整个事务。</li><li>如果某个服务的 Try 逻辑有问题，TCC 分布式事务框架感知到之后就会推进执行各个服务的 Cancel 逻辑，撤销之前执行的各种操作。</li></ul><p>这就是所谓的 TCC 分布式事务。TCC 分布式事务的核心思想，说白了，就是当遇到下面这些情况时：</p><ul><li>某个服务的数据库宕机了。</li><li>某个服务自己挂了。</li><li>那个服务的 Redis、Elasticsearch、MQ 等基础设施故障了。</li><li>某些资源不足了，比如说库存不够这些。</li></ul><p>先来 Try 一下，不要把业务逻辑完成，先试试看，看各个服务能不能基本正常运转，能不能先冻结我需要的资源。</p><p>如果 Try 都 OK，也就是说，底层的数据库、Redis、Elasticsearch、MQ 都是可以写入数据的，并且你保留好了需要使用的一些资源（比如冻结了一部分库存）。</p><p>接着，再执行各个服务的 Confirm 逻辑，基本上 Confirm 就可以很大概率保证一个分布式事务的完成了。</p><p>那如果 Try 阶段某个服务就失败了，比如说底层的数据库挂了，或者 Redis 挂了，等等。</p><p>此时就自动执行各个服务的 Cancel 逻辑，把之前的 Try 逻辑都回滚，所有服务都不要执行任何设计的业务逻辑。保证大家要么一起成功，要么一起失败。</p><p>等一等，你有没有想到一个问题？如果有一些意外的情况发生了，比如说订单服务突然挂了，然后再次重启，TCC 分布式事务框架是如何保证之前没执行完的分布式事务继续执行的呢？</p><p>所以，TCC 事务框架都是要记录一些分布式事务的活动日志的，可以在磁盘上的日志文件里记录，也可以在数据库里记录。保存下来分布式事务运行的各个阶段和状态。</p><p>问题还没完，万一某个服务的 Cancel 或者 Confirm 逻辑执行一直失败怎么办呢？</p><p>那也很简单，TCC 事务框架会通过活动日志记录各个服务的状态。举个例子，比如发现某个服务的 Cancel 或者 Confirm 一直没成功，会不停的重试调用它的 Cancel 或者 Confirm 逻辑，务必要它成功！</p><p>当然了，如果你的代码没有写什么 Bug，有充足的测试，而且 Try 阶段都基本尝试了一下，那么其实一般 Confirm、Cancel 都是可以成功的！</p><p>最后，再给大家来一张图，来看看给我们的业务，加上分布式事务之后的整个执行流程：</p><p><a href=https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181124232434414-110430781.png target=_blank rel=noopener><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/1162587-20181124232434414-110430781.png alt></a></p><p>不少大公司里，其实都是自己研发 TCC 分布式事务框架的，专门在公司内部使用，比如我们就是这样。</p><p>不过如果自己公司没有研发 TCC 分布式事务框架的话，那一般就会选用开源的框架。</p><p>这里笔者给大家推荐几个比较不错的框架，都是咱们国内自己开源出去的：ByteTCC，TCC-transaction，Himly。</p><p>大家有兴趣的可以去它们的 GitHub 地址，学习一下如何使用，以及如何跟 Spring Cloud、Dubbo 等服务框架整合使用。</p><p>只要把那些框架整合到你的系统里，很容易就可以实现上面那种奇妙的 TCC 分布式事务的效果了。</p><p>下面，我们来讲讲可靠消息最终一致性方案实现的分布式事务，同时聊聊在实际生产中遇到的运用该方案的高可用保障架构。</p><h1 id=最终一致性分布式事务如何保障实际生产中-9999-高可用最终一致性分布式事务如何保障实际生产中-9999-高可用>最终一致性分布式事务如何保障实际生产中 99.99% 高可用？<a href=#%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e5%a6%82%e4%bd%95%e4%bf%9d%e9%9a%9c%e5%ae%9e%e9%99%85%e7%94%9f%e4%ba%a7%e4%b8%ad-9999-%e9%ab%98%e5%8f%af%e7%94%a8>#</a></h1><p>上面咱们聊了聊 TCC 分布式事务，对于常见的微服务系统，大部分接口调用是同步的，也就是一个服务直接调用另外一个服务的接口。</p><p>这个时候，用 TCC 分布式事务方案来保证各个接口的调用，要么一起成功，要么一起回滚，是比较合适的。</p><p>但是在实际系统的开发过程中，可能服务间的调用是异步的。也就是说，一个服务发送一个消息给 MQ，即消息中间件，比如 RocketMQ、RabbitMQ、Kafka、ActiveMQ 等等。</p><p>然后，另外一个服务从 MQ 消费到一条消息后进行处理。这就成了基于 MQ 的异步调用了。</p><p>那么针对这种基于 MQ 的异步调用，如何保证各个服务间的分布式事务呢？也就是说，我希望的是基于 MQ 实现异步调用的多个服务的业务逻辑，要么一起成功，要么一起失败。</p><p>这个时候，就要用上可靠消息最终一致性方案，来实现分布式事务。</p><p><a href=https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181124232543507-80796570.png target=_blank rel=noopener><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/1162587-20181124232543507-80796570.png alt></a></p><p>大家看上图，如果不考虑各种高并发、高可用等技术挑战的话，单从 “可靠消息” 以及 “最终一致性” 两个角度来考虑，这种分布式事务方案还是比较简单的。</p><h2 id=可靠消息最终一致性方案的核心流程可靠消息最终一致性方案的核心流程>可靠消息最终一致性方案的核心流程<a href=#%e5%8f%af%e9%9d%a0%e6%b6%88%e6%81%af%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7%e6%96%b9%e6%a1%88%e7%9a%84%e6%a0%b8%e5%bf%83%e6%b5%81%e7%a8%8b>#</a></h2><h3 id=上游服务投递消息上游服务投递消息>①上游服务投递消息<a href=#%e4%b8%8a%e6%b8%b8%e6%9c%8d%e5%8a%a1%e6%8a%95%e9%80%92%e6%b6%88%e6%81%af>#</a></h3><p>如果要实现可靠消息最终一致性方案，一般你可以自己写一个可靠消息服务，实现一些业务逻辑。</p><p><strong>首先</strong>，上游服务需要发送一条消息给可靠消息服务。这条消息说白了，你可以认为是对下游服务一个接口的调用，里面包含了对应的一些请求参数。</p><p><strong>然后</strong>，可靠消息服务就得把这条消息存储到自己的数据库里去，状态为 “待确认”。</p><p><strong>接着</strong>，上游服务就可以执行自己本地的数据库操作，根据自己的执行结果，再次调用可靠消息服务的接口。</p><p>如果本地数据库操作执行成功了，那么就找可靠消息服务确认那条消息。如果本地数据库操作失败了，那么就找可靠消息服务删除那条消息。</p><p>此时如果是确认消息，那么可靠消息服务就把数据库里的消息状态更新为 “已发送”，同时将消息发送给 MQ。</p><p>这里有一个很关键的点，就是更新数据库里的消息状态和投递消息到 MQ。这俩操作，你得放在一个方法里，而且得开启本地事务。</p><p>啥意思呢？如果数据库里更新消息的状态失败了，那么就抛异常退出了，就别投递到 MQ；如果投递 MQ 失败报错了，那么就要抛异常让本地数据库事务回滚。这俩操作必须得一起成功，或者一起失败。</p><p>如果上游服务是通知删除消息，那么可靠消息服务就得删除这条消息。</p><h3 id=下游服务接收消息下游服务接收消息>②下游服务接收消息<a href=#%e4%b8%8b%e6%b8%b8%e6%9c%8d%e5%8a%a1%e6%8e%a5%e6%94%b6%e6%b6%88%e6%81%af>#</a></h3><p>下游服务就一直等着从 MQ 消费消息好了，如果消费到了消息，那么就操作自己本地数据库。</p><p>如果操作成功了，就反过来通知可靠消息服务，说自己处理成功了，然后可靠消息服务就会把消息的状态设置为 “已完成”。</p><h3 id=如何保证上游服务对消息的-100-可靠投递如何保证上游服务对消息的-100-可靠投递>③如何保证上游服务对消息的 100% 可靠投递？<a href=#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e4%b8%8a%e6%b8%b8%e6%9c%8d%e5%8a%a1%e5%af%b9%e6%b6%88%e6%81%af%e7%9a%84-100-%e5%8f%af%e9%9d%a0%e6%8a%95%e9%80%92>#</a></h3><p>上面的核心流程大家都看完：一个很大的问题就是，如果在上述投递消息的过程中各个环节出现了问题该怎么办？</p><p>我们如何保证消息 100% 的可靠投递，一定会从上游服务投递到下游服务？别着急，下面我们来逐一分析。</p><p>如果上游服务给可靠消息服务发送待确认消息的过程出错了，那没关系，上游服务可以感知到调用异常的，就不用执行下面的流程了，这是没问题的。</p><p>如果上游服务操作完本地数据库之后，通知可靠消息服务确认消息或者删除消息的时候，出现了问题。</p><p>比如：没通知成功，或者没执行成功，或者是可靠消息服务没成功的投递消息到 MQ。这一系列步骤出了问题怎么办？</p><p>其实也没关系，因为在这些情况下，那条消息在可靠消息服务的数据库里的状态会一直是 “待确认”。</p><p>此时，我们在可靠消息服务里开发一个后台定时运行的线程，不停的检查各个消息的状态。</p><p>如果一直是 “待确认” 状态，就认为这个消息出了点什么问题。此时的话，就可以回调上游服务提供的一个接口，问问说，兄弟，这个消息对应的数据库操作，你执行成功了没啊？</p><p>如果上游服务答复说，我执行成功了，那么可靠消息服务将消息状态修改为 “已发送”，同时投递消息到 MQ。</p><p>如果上游服务答复说，没执行成功，那么可靠消息服务将数据库中的消息删除即可。</p><p>通过这套机制，就可以保证，可靠消息服务一定会尝试完成消息到 MQ 的投递。</p><h3 id=如何保证下游服务对消息的-100-可靠接收如何保证下游服务对消息的-100-可靠接收>④如何保证下游服务对消息的 100% 可靠接收？<a href=#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e4%b8%8b%e6%b8%b8%e6%9c%8d%e5%8a%a1%e5%af%b9%e6%b6%88%e6%81%af%e7%9a%84-100-%e5%8f%af%e9%9d%a0%e6%8e%a5%e6%94%b6>#</a></h3><p>那如果下游服务消费消息出了问题，没消费到？或者是下游服务对消息的处理失败了，怎么办？</p><p>其实也没关系，在可靠消息服务里开发一个后台线程，不断的检查消息状态。</p><p>如果消息状态一直是 “已发送”，始终没有变成 “已完成”，那么就说明下游服务始终没有处理成功。</p><p>此时可靠消息服务就可以再次尝试重新投递消息到 MQ，让下游服务来再次处理。</p><p>只要下游服务的接口逻辑实现幂等性，保证多次处理一个消息，不会插入重复数据即可。</p><h3 id=如何基于-rocketmq-来实现可靠消息最终一致性方案如何基于-rocketmq-来实现可靠消息最终一致性方案>⑤如何基于 RocketMQ 来实现可靠消息最终一致性方案？<a href=#%e5%a6%82%e4%bd%95%e5%9f%ba%e4%ba%8e-rocketmq-%e6%9d%a5%e5%ae%9e%e7%8e%b0%e5%8f%af%e9%9d%a0%e6%b6%88%e6%81%af%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7%e6%96%b9%e6%a1%88>#</a></h3><p>在上面的通用方案设计里，完全依赖可靠消息服务的各种自检机制来确保：</p><ul><li>如果上游服务的数据库操作没成功，下游服务是不会收到任何通知。</li><li>如果上游服务的数据库操作成功了，可靠消息服务死活都会确保将一个调用消息投递给下游服务，而且一定会确保下游服务务必成功处理这条消息。</li></ul><p>通过这套机制，保证了基于 MQ 的异步调用 / 通知的服务间的分布式事务保障。其实阿里开源的 RocketMQ，就实现了可靠消息服务的所有功能，核心思想跟上面类似。</p><p>只不过 RocketMQ 为了保证高并发、高可用、高性能，做了较为复杂的架构实现，非常的优秀。有兴趣的同学，自己可以去查阅 RocketMQ 对分布式事务的支持。</p><h2 id=可靠消息最终一致性方案的高可用保障生产实践可靠消息最终一致性方案的高可用保障生产实践>可靠消息最终一致性方案的高可用保障生产实践<a href=#%e5%8f%af%e9%9d%a0%e6%b6%88%e6%81%af%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7%e6%96%b9%e6%a1%88%e7%9a%84%e9%ab%98%e5%8f%af%e7%94%a8%e4%bf%9d%e9%9a%9c%e7%94%9f%e4%ba%a7%e5%ae%9e%e8%b7%b5>#</a></h2><h3 id=背景引入背景引入>背景引入<a href=#%e8%83%8c%e6%99%af%e5%bc%95%e5%85%a5>#</a></h3><p>上面那套方案和思想，很多同学应该都知道是怎么回事儿，我们也主要就是铺垫一下这套理论思想。</p><p>在实际落地生产的时候，如果没有高并发场景的，完全可以参照上面的思路自己基于某个 MQ 中间件开发一个可靠消息服务。</p><p>如果有高并发场景的，可以用 RocketMQ 的分布式事务支持上面的那套流程都可以实现。</p><p>今天给大家分享的一个核心主题，就是这套方案如何保证 99.99% 的高可用。</p><p>大家应该发现了这套方案里保障高可用性最大的一个依赖点，就是 MQ 的高可用性。</p><p>任何一种 MQ 中间件都有一整套的高可用保障机制，无论是 RabbitMQ、RocketMQ 还是 Kafka。</p><p>所以在大公司里使用可靠消息最终一致性方案的时候，我们通常对可用性的保障都是依赖于公司基础架构团队对 MQ 的高可用保障。</p><p>也就是说，大家应该相信兄弟团队，99.99% 可以保障 MQ 的高可用，绝对不会因为 MQ 集群整体宕机，而导致公司业务系统的分布式事务全部无法运行。</p><p>但是现实是很残酷的，很多中小型的公司，甚至是一些中大型公司，或多或少都遇到过 MQ 集群整体故障的场景。</p><p>MQ 一旦完全不可用，就会导致业务系统的各个服务之间无法通过 MQ 来投递消息，导致业务流程中断。</p><p>比如最近就有一个朋友的公司，也是做电商业务的，就遇到了 MQ 中间件在自己公司机器上部署的集群整体故障不可用，导致依赖 MQ 的分布式事务全部无法跑通，业务流程大量中断的情况。</p><p>这种情况，就需要针对这套分布式事务方案实现一套高可用保障机制。</p><h3 id=基于-kv-存储的队列支持的高可用降级方案基于-kv-存储的队列支持的高可用降级方案>基于 KV 存储的队列支持的高可用降级方案<a href=#%e5%9f%ba%e4%ba%8e-kv-%e5%ad%98%e5%82%a8%e7%9a%84%e9%98%9f%e5%88%97%e6%94%af%e6%8c%81%e7%9a%84%e9%ab%98%e5%8f%af%e7%94%a8%e9%99%8d%e7%ba%a7%e6%96%b9%e6%a1%88>#</a></h3><p>大家来看看下面这张图，这是我曾经指导过朋友的一个公司针对可靠消息最终一致性方案设计的一套高可用保障降级机制。</p><p>这套机制不算太复杂，可以非常简单有效的保证那位朋友公司的高可用保障场景，一旦 MQ 中间件出现故障，立马自动降级为备用方案。</p><p><a href=https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181124232927245-945975189.png target=_blank rel=noopener><img src=https://bucket-typora-kw.oss-cn-beijing.aliyuncs.com/typora-image/1162587-20181124232927245-945975189.png alt></a></p><h3 id=自行封装-mq-客户端组件与故障感知自行封装-mq-客户端组件与故障感知>①自行封装 MQ 客户端组件与故障感知<a href=#%e8%87%aa%e8%a1%8c%e5%b0%81%e8%a3%85-mq-%e5%ae%a2%e6%88%b7%e7%ab%af%e7%bb%84%e4%bb%b6%e4%b8%8e%e6%95%85%e9%9a%9c%e6%84%9f%e7%9f%a5>#</a></h3><p>首先第一点，你要做到自动感知 MQ 的故障接着自动完成降级，那么必须动手对 MQ 客户端进行封装，发布到公司 Nexus 私服上去。</p><p>然后公司需要支持 MQ 降级的业务服务都使用这个自己封装的组件来发送消息到 MQ，以及从 MQ 消费消息。</p><p>在你自己封装的 MQ 客户端组件里，你可以根据写入 MQ 的情况来判断 MQ 是否故障。</p><p>比如说，如果连续 10 次重新尝试投递消息到 MQ 都发现异常报错，网络无法联通等问题，说明 MQ 故障，此时就可以自动感知以及自动触发降级开关。</p><h3 id=基于-kv-存储中队列的降级方案基于-kv-存储中队列的降级方案>②基于 KV 存储中队列的降级方案<a href=#%e5%9f%ba%e4%ba%8e-kv-%e5%ad%98%e5%82%a8%e4%b8%ad%e9%98%9f%e5%88%97%e7%9a%84%e9%99%8d%e7%ba%a7%e6%96%b9%e6%a1%88>#</a></h3><p>如果 MQ 挂掉之后，要是希望继续投递消息，那么就必须得找一个 MQ 的替代品。</p><p>举个例子，比如我那位朋友的公司是没有高并发场景的，消息的量很少，只不过可用性要求高。此时就可以使用类似 Redis 的 KV 存储中的队列来进行替代。</p><p>由于 Redis 本身就支持队列的功能，还有类似队列的各种数据结构，所以你可以将消息写入 KV 存储格式的队列数据结构中去。</p><p>PS：关于 Redis 的数据存储格式、支持的数据结构等基础知识，请大家自行查阅了，网上一大堆。</p><p>但是，这里有几个大坑，一定要注意一下：</p><p><strong>第一个</strong>，任何 KV 存储的集合类数据结构，建议不要往里面写入数据量过大，否则会导致大 Value 的情况发生，引发严重的后果。</p><p>因此绝不能在 Redis 里搞一个 Key，就拼命往这个数据结构中一直写入消息，这是肯定不行的。</p><p><strong>第二个</strong>，绝对不能往少数 Key 对应的数据结构中持续写入数据，那样会导致热 Key 的产生，也就是某几个 Key 特别热。</p><p>大家要知道，一般 KV 集群，都是根据 Key 来 Hash 分配到各个机器上的，你要是老写少数几个 Key，会导致 KV 集群中的某台机器访问过高，负载过大。</p><p>基于以上考虑，下面是笔者当时设计的方案：</p><ul><li>根据它们每天的消息量，在 KV 存储中固定划分上百个队列，有上百个 Key 对应。</li><li>这样保证每个 Key 对应的数据结构中不会写入过多的消息，而且不会频繁的写少数几个 Key。</li><li>一旦发生了 MQ 故障，可靠消息服务可以对每个消息通过 Hash 算法，均匀的写入固定好的上百个 Key 对应的 KV 存储的队列中。</li></ul><p>同时需要通过 ZK 触发一个降级开关，整个系统在 MQ 这块的读和写全部立马降级。</p><h3 id=下游服务消费-mq-的降级感知下游服务消费-mq-的降级感知>③下游服务消费 MQ 的降级感知<a href=#%e4%b8%8b%e6%b8%b8%e6%9c%8d%e5%8a%a1%e6%b6%88%e8%b4%b9-mq-%e7%9a%84%e9%99%8d%e7%ba%a7%e6%84%9f%e7%9f%a5>#</a></h3><p>下游服务消费 MQ 也是通过自行封装的组件来做的，此时那个组件如果从 ZK 感知到降级开关打开了，首先会判断自己是否还能继续从 MQ 消费到数据？</p><p>如果不能了，就开启多个线程，并发的从 KV 存储的各个预设好的上百个队列中不断的获取数据。</p><p>每次获取到一条数据，就交给下游服务的业务逻辑来执行。通过这套机制，就实现了 MQ 故障时候的自动故障感知，以及自动降级。如果系统的负载和并发不是很高的话，用这套方案大致是没问题的。</p><p>因为在生产落地的过程中，包括大量的容灾演练以及生产实际故障发生时的表现来看，都是可以有效的保证 MQ 故障时，业务流程继续自动运行的。</p><h3 id=故障的自动恢复故障的自动恢复>④故障的自动恢复<a href=#%e6%95%85%e9%9a%9c%e7%9a%84%e8%87%aa%e5%8a%a8%e6%81%a2%e5%a4%8d>#</a></h3><p>如果降级开关打开之后，自行封装的组件需要开启一个线程，每隔一段时间尝试给 MQ 投递一个消息看看是否恢复了。</p><p>如果 MQ 已经恢复可以正常投递消息了，此时就可以通过 ZK 关闭降级开关，然后可靠消息服务继续投递消息到 MQ，下游服务在确认 KV 存储的各个队列中已经没有数据之后，就可以重新切换为从 MQ 消费消息。</p><h3 id=更多的业务细节更多的业务细节>⑤更多的业务细节<a href=#%e6%9b%b4%e5%a4%9a%e7%9a%84%e4%b8%9a%e5%8a%a1%e7%bb%86%e8%8a%82>#</a></h3><p>上面说的那套方案是一套通用的降级方案，但是具体的落地是要结合各个公司不同的业务细节来决定的，很多细节多没法在文章里体现。</p><p>比如说你们要不要保证消息的顺序性？是不是涉及到需要根据业务动态，生成大量的 Key？等等。</p><p>此外，这套方案实现起来还是有一定的成本的，所以建议大家尽可能还是 Push 公司的基础架构团队，保证 MQ 的 99.99% 可用性，不要宕机。</p><p>其次就是根据大家公司实际对高可用的需求来决定，如果感觉 MQ 偶尔宕机也没事，可以容忍的话，那么也不用实现这种降级方案。</p><p>但是如果公司领导认为 MQ 中间件宕机后，一定要保证业务系统流程继续运行，那么还是要考虑一些高可用的降级方案，比如本文提到的这种。</p><p>最后再说一句，真要是一些公司涉及到每秒几万几十万的高并发请求，那么对 MQ 的降级方案会设计的更加的复杂，那就远远不是这么简单可以做到的。</p><p>​</p></div><footer class=post-footer><div class=post-tags><a href=/tags/tcc rel=tag title=tcc>#tcc#</a>
<a href=/tags/%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1 rel=tag title=分布式事务>#分布式事务#</a></div><div class=addthis_inline_share_toolbox></div><div class=post-nav><div class=article-copyright><div class=article-copyright-img><img src=/img/qq_qrcode.png width=129px height=129px><div style=text-align:center>QQ扫一扫交流</div></div><div class=article-copyright-info><p><span>标题：</span>TCC 分布式事务</p><p><span>链接：</span>https://codingroam.github.io/post/tcc-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</p><p><span>作者：</span>roam</p><p><span>声明： </span>本博客文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank style=text-decoration:underline>CC BY-NC-SA 3.0</a>许可协议，转载请注明出处！</p></div></div><div class=clear></div></div><div class=reward-qr-info><div>创作实属不易，如有帮助，那就打赏博主些许茶钱吧 ^_^</div><button id=rewardButton disable=enable onclick='var qr=document.getElementById("QR");qr.style.display==="none"?qr.style.display="block":qr.style.display="none"'>
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/img/wechat-pay.png alt="WeChat Pay"><p>微信打赏</p></div><div id=alipay style=display:inline-block><img id=alipay_qr src=/img/ali-pay.png alt=Alipay><p>支付宝打赏</p></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"></div><div class="post-nav-prev post-nav-item"><a href=https://codingroam.github.io/post/sql%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE/ rel=prev title=sql删除重复数据>sql删除重复数据
<i class="fa fa-chevron-right"></i></a></div></div><div id=wcomments></div></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.png alt=roam><p class=site-author-name itemprop=name>roam</p><p class="site-description motion-element" itemprop=description>以为打得赢我啊你</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>77</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>30</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>54</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/wk123456/ target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://www.zhihu.com/ target=_blank title=知乎><i class="fa fa-fw fa-globe"></i>
知乎</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class=links-of-blogroll-title><i class="fa fa-fw fa-globe"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://nutzam.com/ title=Nutz target=_blank>Nutz</a></li><li class=links-of-blogroll-item><a href=https://jfinal.com/ title=JFinal target=_blank>JFinal</a></li><li class=links-of-blogroll-item><a href=http://wendal.net/ title=Wendal target=_blank>Wendal</a></li><li class=links-of-blogroll-item><a href=https://www.liaoxuefeng.com/ title=廖雪峰 target=_blank>廖雪峰</a></li></ul></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/learning>Learning
<sup>27</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/java>Java
<sup>11</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/mysql>Mysql
<sup>11</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6>中间件
<sup>10</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/golang>Golang
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/golang%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0>Golang编程学习
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/linux>Linux
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/redis>Redis
<sup>8</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/problem-solving>Problem solving
<sup>7</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/docker>Docker
<sup>6</sup></a></li></ul></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>想学啊你</span></div><div class=powered-info><span class=powered-by>Powered by - <a class=powered-link href=//gohugo.io target=_blank title=hugo>Hugo v0.115.4</a></span>
<span class=separator-line>/</span>
<span class=theme-info>Theme by - <a class=powered-link href=//github.com/elkan1788/hugo-theme-next target=_blank>NexT</a></span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href=https://gitee.com/ style=font-weight:700 target=_blank>Gitee 仓库</a></span>
<span class=separator-line>/</span>
<span class=license-num><a href=http://beian.miit.gov.cn target=_blank>粤 ICP 备 18047355 号</a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//unpkg.com/jquery@2.1.4/dist/jquery.min.js></script>
<script type=text/javascript src=https://codingroam.github.io/js/search.js></script>
<script type=text/javascript src=https://codingroam.github.io/js/affix.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".footer").outerHeight(!0),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var e,t,n,s,o=$(".header-inner").height()+10;$("#sidebar").css({"margin-top":o}).show(),t=parseInt($("#sidebar").css("margin-top")),n=parseInt($(".sidebar-inner").css("height")),e=t+n,s=$(".content-wrap").height(),s<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script type=text/javascript>const locale={placeholder:"欢迎留下您的宝贵建议，请填写您的昵称和邮箱便于后续交流. ^_^"};$(function(){detectIE()>0?$.getScript(document.location.protocol+"//unpkg.com/@waline/client@1.6.0/dist/Waline.min.js",function(){new Waline({el:"#wcomments",visitor:!0,emoji:[],wordLimit:"200",uploadImage:!1,locale,requiredMeta:["nick","mail"],serverURL:"Your WalineSerURL",lang:"zh-cn"})}):$("#wcomments").html("抱歉，Waline插件不支持IE或Edge，建议使用Chrome浏览器。")})</script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script>
<script>(function(){var t,e=document.createElement("script"),n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>