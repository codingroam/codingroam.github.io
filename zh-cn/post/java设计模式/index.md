# java设计模式


java 设计模式学习

<!--more-->

### 1 七大原则

1. **单一职责原则**：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因

2. **开闭原则**：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。

3. **里氏代换原则**：**所有引用基类（父类）的地方必须能透明地使用其子类的对象**。里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此**在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象**

   在使用里氏代换原则时需要注意如下几个问题：

   + 子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原 则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。
   + 我们在运用里氏代换原则时，**尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法**，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。

4. **依赖倒转原则**：抽象不应该依赖于细节，细节应当 依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。**依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类**，即使 

   用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。

   > 在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象 发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入

5. **接口隔离原则**：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

6. **合成复用原则**：**尽量使用对象组合，而不是继承来达到复用的目的**。合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。

   > 两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继 承。”Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。

7. **迪米特法则**：一个软件实体应当尽可能少地与其他实体发生相互作用（**最少知道原则**）。

   不要和“陌生人”说话、只与你的直接朋友通信等，在迪米特法 则中，对于一个对象，其朋友包括以下几类：

   + 当前对象本身(this)； 

   + 以参数形式传入到当前对象方法中的对象； 

   +  当前对象的成员对象； 

   + 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友； 

   + 当前对象所创建的对象。 

   任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。

   迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接 通信，那么这两个对象就不应该发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象 的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低 现有对象之间的耦合度。

---

> 作者: wang  
> URL: https://codingroam.github.io/zh-cn/post/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/  

